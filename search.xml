<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F04%2F19%2F10%2F</url>
    <content type="text"><![CDATA[插入排序$O(n^2)$123456789101112void insertion_sort()&#123; int i, j; cout &lt;&lt; "insertion_sort:\n"; for(i = 0; i &lt; N; i ++ ) &#123; int t = a[i]; for(j = i - 1; j &gt;= 0 &amp;&amp; t &lt; a[j]; j -- ) a[j + 1] = a[j]; a[j + 1] = t; &#125; &#125; 归并排序1234567891011121314151617void merge_sort(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid); merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) if(a[i] &lt;= a[j]) w[k ++ ] = a[i ++ ]; else w[k ++ ] = a[j ++ ]; // cnt += mid – i + 1 归并排序求逆序对 while(i &lt;= mid) w[k ++ ] = a[i ++ ]; while(j &lt;= r) w[k ++ ] = a[j ++ ]; for(i = l, j = 0; j &lt; k; i ++, j ++ ) a[i] = w[j];&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路模板]]></title>
    <url>%2F2019%2F04%2F19%2F9%2F</url>
    <content type="text"><![CDATA[邻接表存图1234567891011int n, m, tot; //n个点，m条边，tot为边的个数int edge[M], ver[M], Next[M]; //边权值，顶点，接着的边（tot序号）int d[N], head[N]; //每个点的最短距离，链表头bool v[N]; //访问标记void add(int x, int y, int z) //起点，终点，边权值&#123; ver[++ tot] = y; //终点 edge[tot] = z; //这个边的边权值 Next[tot] = head[x]; //由于从链表头开始插入，则表头存这个边的序号 head[x] = tot; //这边链接的下一个连接原来的表头，最后传递遍历到0，表示结束&#125; dijkstra算法dijkstra堆优化时间复杂度: $(m + n)logn -&gt; mlogn$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; #include &lt;cstring&gt;using namespace std;const int N = 5e2; //顶点数 const int M = 5e3; //边数 typedef pair&lt;int, int&gt; PII;int n, m, tot;int edge[M], ver[M], Next[M];int d[N], head[N];bool v[N];void add(int x, int y, int z) //见邻接表存图&#123; ver[++ tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;&#125;void dijkstra()&#123; memset(d, 0x3f, sizeof(d)); //初始距离为inf memset(v, 0 , sizeof(v)); //每个点没有被标记 priority_queue&lt;PII&gt; q; //添-号变成小根堆 q.push(&#123;0, 1&#125;); //1 到 1边权值为 0 d[1] = 0; while(!q.empty()) &#123; int x = q.top().second; //终点 q.pop(); if(v[x]) continue; //访问过的点不在加入 v[x] = 1; for(int i = head[x]; i ; i = Next[i]) //通过边的序号进行遍历，y为终点，z为边权值 &#123; int y = ver[i], z = edge[i]; if(d[y] &gt; d[x] + z) //如果不满足三角形定则，则进行更新 &#123; d[y] = d[x] + edge[i]; q.push(&#123;-d[y], y&#125;); //取-变小根堆，边权值，终点 &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); add(x, y, z); //无向图双向加入 add(y, x, z); &#125; dijkstra(); for(int i = 1; i &lt;= n; i ++ ) //输出每个顶点最短距离 cout &lt;&lt; d[i] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2F2019%2F04%2F18%2F8%2F</url>
    <content type="text"><![CDATA[prim算法优点：对稠密图效率高缺点：复杂度为 $O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 3010;int a[N][N], d[N], n, m, ans; //邻接矩阵a，最小生成树集合(T)里的点到其它(S)集合的点y (y 属于 S) d[y] = min(d[y], a[x][y]) // v[y] = 1表示点y在集合T中，否则在其它集合(S)中，按顺序每次枚举结点，加入T集合 bool v[N]; //标记数组 void prim()&#123; memset(d, 0x3f, sizeof(d)); //每个点到T集合的距离初始化为无穷大 for(int i = 1; i &lt; n; i ++ ) //顺序枚举每个点，最后一个点时其它所有点已经被访问d[n]会被自身a[n][n]更新为0，所以不用要n节点 &#123; int x = 0; //记录最近节点下标，每次将第一个数纳入 for(int j = 1; j &lt;= n; j ++ ) //记录离T集合最近的点 if(!v[j] &amp;&amp; (x == 0 || d[j] &lt; d[x])) x = j; v[x] = 1; for(int y = 1; y &lt;= n; y ++ ) //新加入的点与S集合里的点进行y (y 属于 S) 与 T集合最近距离的更新，方便下一次选，没有路径和为inf if(!v[y]) d[y] = min(d[y], a[x][y]); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //n个节点，m条边 memset(a, 0x3f, sizeof(a)); //所有点距初始化为inf,即没有边相连 for(int i = 1; i &lt;= n; i ++ ) a[i][i] = 0; //自己与自己没有边，距离为0; for(int i = 1; i &lt;= m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); //起点 终点 权值 a[x][y] = a[y][x] = min(z, a[x][y]); //由于可能两点之间多边，又是无向图，连两条边，更新两点之间的最短距离 &#125; prim(); for(int i = 2; i &lt;= n; i ++ ) //由于d[1]为0， 所以即从d[2] + ···+ d[n]即可 ans += d[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; kruskal算法$(并查集 + 贪心)$ 优点：复杂度较低 $O(nlogn)$，实现简单缺点：边数较多，即稠密图中效率较低思想 : 通过边进行贪心思想，优先选择边权值小的，并且这两个端点不能在同一个集合里(即不连通，否则加上会出现环) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5e5 + 20; //边集 const int M = 1e5 + 20; //顶点集 struct rec&#123; //线段结构体, 起点，终点，权值 int x, y, z; bool operator &lt; (const rec a) const&#123; //按小权值(e[i].z)排序 return z &lt; a.z; &#125;&#125;e[N];int n, m, ans, fa[M]; //顶点(vertex)数, 边(edge)数，答案，父亲节点(并查集中使用) void init() //并查集 (并查集的初始化不能忘) &#123; for(int i = 1; i &lt;= n; i ++ ) fa[i] = i;&#125;int get(int x)&#123; return fa[x] == x ? x : fa[x] = get(fa[x]);&#125;void unite(int x, int y)&#123; fa[get(x)] = get(y); &#125;bool same(int x, int y)&#123; return get(x) == get(y);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i ++ ) scanf("%d %d %d", &amp;e[i].x, &amp;e[i].y, &amp;e[i].z); init(); //每个节点父亲节点初始化为自身(不能忘记初始化) sort(e + 1, e + m + 1); //按小到大排序 for(int i = 1; i &lt;= m; i ++ ) //按边权值从小到大枚举 &#123; if(same(e[i].x, e[i].y)) //两端点是否连通(父节点是否相同) continue; unite(e[i].x, e[i].y); //两端点不连通，合并两点，加上答案 ans += e[i].z; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度计算]]></title>
    <url>%2F2019%2F04%2F18%2F7%2F</url>
    <content type="text"><![CDATA[高精度(高精度 * int)12345678910111213141516171819vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) //高精度乘法&#123;if(b == 0 || (a.size() == 1 &amp;&amp; a[0] == 0)) //乘积为0的两种特殊情况 return vector&lt;int&gt; (1, 0); //返回容器式的 0 vector&lt;int&gt; c; //答案(由于从低位开始算，最终答案会是逆序) int t = 0; //每一位上的乘积结果 for(int i = a.size() - 1; i &gt;= 0; i -- ) &#123; t += a[i] * b; //模拟人工手算，高精度的每一位乘上b c.push_back(t % 10); //将最低位存入答案，下一位进行计算时需要进位 t /= 10; //进位，右移(模拟手算) &#125; while(t) //剩下的位继续存入答案 &#123; c.push_back(t % 10); //取最低位 t /= 10; //进位，左移，方便与高位进行运算 &#125; return vector&lt;int&gt; (c.rbegin(), c.rend()); //由于答案是逆序的，再逆序返回&#125; 高精度 / int1234567891011121314151617181920212223242526vector&lt;int&gt; div(vector&lt;int&gt; a, int b) //高精度除法&#123; vector&lt;int&gt; res; int t = 0; //进行积累的被除数 bool first = true; //判断第一个没有出现的0为止(前缀会有无用0，这样可以丢弃那些 0) for(int i = 0; i &lt; a.size(); i ++ ) //除法，高位往低位移 &#123; t = t * 10 + a[i]; //模拟手工除法，每次向后移一位 int x = t / b; //每步的除数 if(!first || x) //如果能除数大于0(找到第一个不为0的位置) &#123; first = false; //找到第一个不为0的位置，之后的每步计算结果都记录(包括后面的 0) res.push_back(x); //存入答案，这是正序(由于是高位往低位) &#125; t %= b; //取余数继续进行下一次的除 &#125; return res;&#125;vector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b) //高精度比大小&#123; //a, b都是正序 if(a.size() &gt; b.size()) return a; //a的位数更多 if(a.size() &lt; b.size()) return b; //b的位数更多 if(a &gt; b) return a; //相同位数直接比字典序 return b;&#125; 高精度 + 高精度12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef vector&lt;int&gt; vec;vec pluss(vec a, vec b, int len) //都是vec类型相加，答案最大长度为max_len(a, b) + 1&#123; vec ans; int t = 0; for(int i = 0; i &lt; len; i ++ ) //倒序相加，由于处理时是逆序存入的 &#123; t += a[i] + b[i]; //上一位进来的数 + 本身这位的两位数 ans.push_back(t % 10); //取余 t /= 10; //进位 &#125; if(t) ans.push_back(t); //由于答案 &gt;= max_len return vec (ans.rbegin(), ans.rend()); //调整为正序返回&#125;char s1[501], s2[501];int main()&#123; int i, k, len = 0; vec a(500), b(500); scanf("%s", s1); for(i = strlen(s1) - 1, k = 0; i &gt;= 0; i --, k ++ ) //逆序输入处理 a[k] = s1[i] - '0'; len = max(len, k); scanf("%s", s2); for(i = strlen(s2) - 1, k = 0; i &gt;= 0; i --, k ++ ) b[k] = s2[i] - '0'; len = max(len, k); vec res = pluss(a, b, len); for(auto x : res) cout &lt;&lt; x; return 0;&#125; 高精度 * 高精度思想：点阵乘法 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef vector&lt;int&gt; vec;vec mul(vec a, vec b, int len)&#123; if(a.size() == 1 &amp;&amp; a[0] == 0 || (b[0] == 0 &amp;&amp; b.size() == 1)) //被乘数含0，直接返回0 return vec (1, 0); vec ans(len); for(int i = 0; i &lt; a.size(); i ++ ) for(int j = 0; j &lt; b.size(); j ++ ) ans[len - 2 - i - j] += a[i] * b[j]; //对应位 for(int i = 0; i &lt; len - 1; i ++ ) &#123; ans[i + 1] += ans[i] / 10; ans[i] %= 10; &#125; if(!ans[len - 1]) ans.pop_back(); //pro最大为a + b, 最小为a + b - 1 return vec (ans.rbegin(), ans.rend()); //还原顺序返回&#125;char s1[501], s2[501];int main()&#123; vec a, b; int len = 0; scanf("%s", s1); //处理输入 for(int i = 0; i &lt; strlen(s1); i ++ ) a.push_back(s1[i] - '0'); len += strlen(s1); scanf("%s", s2); len += strlen(s2); for(int i = 0; i &lt; strlen(s2); i ++ ) b.push_back(s2[i] - '0'); vec res = mul(a, b, len); //最长可能长度 for(auto x : res) cout &lt;&lt; x; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化模板]]></title>
    <url>%2F2019%2F04%2F18%2F6%2F</url>
    <content type="text"><![CDATA[离散化123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 4;int a[N]; //原本数组 int ls[N]; //离散化后的数组 int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; a[i]; ls[i] = a[i]; //对原数组进行备份 &#125; sort(ls, ls + n); //对原数组(即备份数组进行排序) int len = unique(ls, ls + n) - ls; //进行去重减少离散长度(避免出现原数组1 1 2 2 离散为1 1 3 3的情况) for(int i = 0; i &lt; n; i ++) a[i] = lower_bound(ls, ls + len, a[i]) - ls + 1; //将原数组进行离散化记录排序下标(即离散化) ，在有效长度len中进行搜索映射 for(int i = 0; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; " "; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集模板]]></title>
    <url>%2F2019%2F04%2F18%2F5%2F</url>
    <content type="text"><![CDATA[标准(自改型和其一样，查询为O(1), 路径压缩 + 按秩合并) 12345678910111213141516171819202122232425262728293031const int MN = 50;int par[MN], heig[MN];void init(int n) //初始化 每个点的根节点先初始化为自己，此时树的高度为0 &#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x) //查找根节点 &#123; if(par[x] == x) return x; //如果找到根节点直接返回（刚开始根节点都初始化为本身） return par[x] = find(par[x]); //递归的进行寻找，从父节点一个一个往上找 &#125;void unite(int x, int y) //合并 &#123; x = find(x); //由于函数里是备份不会改变原有值直接操作 y = find(y); //找到x，y的根节点 if(x == y) return; //如果x，y的根节点相同则不用合并 if(heig[x] &lt; heig[y]) //如果y的深度大于x的深度，x接到y上(出于树防树退化的考虑) par[x] = y; //x的根节点变为y的 else &#123; par[y] = x; //否则y接x上 if(heig[x] == heig[y]) heig[x] ++; //如果出现深度相同的情况，那么x的深度+1(深度相等情况的处理) &#125;&#125;bool same(int x, int y) //查找是否为同一个根节点 &#123; return find(x) == find(y);&#125; 自改型12345678910111213141516171819202122232425262728const int N = par[N], heig[N];void init()&#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x)&#123; if(par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x), y = find(y); if(x == y) return; if(heig[x] &gt; heig[y]) par[y] = x; else if(heig[x] == heig[y]) par[y] = x, heig[x] ++; else par[x] = y;&#125;bool same(int x, int y)&#123; return find(x) == find (y);&#125; 并查集 lyd版(查询logn，只用了路径压缩） 123456789101112131415161718void init()&#123; for(int i = 0; i &lt; n; i ++) a[i] = i;&#125;int get(int x)&#123; return x == f[x] ? x : f[x] = get(f[x]);&#125;void merge(int x, int y)&#123; f[get(x)] = get(y); //直接将x的根节点连在y的根节点上&#125;bool same(int x, int y)&#123; return get(x) == get(y);&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组求逆序对]]></title>
    <url>%2F2019%2F04%2F17%2F3%2F</url>
    <content type="text"><![CDATA[思想以当前这个数下标i为标准，遍历前面(0 ~ i - 1)的数，如果大于a[i]则逆序对数 + 1，然后运用桶排序的思想，用a[j]的值作为下标，出现则记录为 1，运用树状数组维护前a[i]个数的和然后用 i - sum(a[i]) 即得到前i个数中本应该小于却没有小的数(即逆序对数) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#define lowbit(x) (x &amp; -x) //lowbit() 运算，取当前第一个 1 出现的位置 using namespace std;const int N = 1e5 + 4;int bit[N]; //bit数组，用二进制思想维护和int n, a[N]; //a数组可有可无，bit的创建通过add(location, value)来确定int sum(int i) //取和操作 &#123; int s = 0; //得到前i个元素的和 //例 : 6 二进制 110, 第一次为自己本身即 s += bit[6] //第二次减去从右往左的第一个1 变为 100 即为4 s += bit[4] //第三次再减去1变为 0 退出 即先使用值再减去第一个 1 for( ; i ; i -= lowbit(i)) s += bit[i]; return s;&#125;void add(int i, int x) //i为位置，x为增量&#123; //与取和操作相反先对 i进行更新，然后加上第一个1之范围会包含原来这个区间，范围更大，都进行更新 //区间最大边界要 &lt;= 最大长度 for( ; i &lt;= n; i += lowbit(i) ) //n为最大限制范围 bit[i] += x; &#125;int main()&#123; cin &gt;&gt; n; int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; //顺序输入 add(a[i], 1); //这个数值进行更新 ans += i - sum(a[i]); //本应小于却没有小于数的个数即为逆序对个数 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树模板]]></title>
    <url>%2F2019%2F04%2F17%2F4%2F</url>
    <content type="text"><![CDATA[lyd 版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1050; //整个大小 int a[N];struct SegmentTree&#123; //线段树结构体，代表每一个节点，左区间，右区间，还有这个区间的特征值(如最大值，最小值) //当 t[ ].l == t[ ].r true时代表一个点 int l, r, dat; &#125;t[N * 4]; //开4倍空间，1. 总数为非2 ^ n 时 logn层即倒数第二层，最后一层还剩了一些节点 // 2. 总数为2 ^ n时为最后一层，还是需要多开一倍(一层),来包涵所有情况void build(int p, int l ,int r) //节点下标，左右区间 &#123; t[p].l = l, t[p].r = r; //建树时记录这个节点代表的区间 if(l == r) &#123; t[p].dat = a[l]; return ; &#125; //如果变成了一个点节点对应原数组值(节点下标类似于堆的储存，为四倍长度) int mid = l + r &gt;&gt; 1; //建树的区间不断分治思想进行划分，左子树 、右子树开始建树 build(p * 2, l, mid); //建立左子树 build(p * 2 + 1, mid + 1, r); //建立右子树 t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //根节点为左右节点的最大值 &#125;//树枝一定有两个叶子节点//证明: 假设树枝只有一个叶子节点，这一个子节点(即叶子)为[x, x]那么往上推，根节点为叶子区间取并，那么根节点也为[x, x]，而根据build函数，l == r true时 //是不会执行子节点的build ，与有子节点矛盾 ，故假设不成立 void change(int p, int x, int v) //节点，修改a[]数组中第几个数，要修改为的值 &#123; if(t[p].l == t[p].r)&#123; t[p].dat = v; return ; &#125; //这个节点区间范围为1(说明找到改的目标值，然后进行 回溯 ，对相关区间的进行更新) (并且这个节点没有子节点) int mid = t[p].l + t[p].r &gt;&gt; 1; //取节点区间的中点值 if(mid &gt;= x) change(p * 2, x, v); //x在这个节点区间的左边，则往下判断左子树 else change(p * 2 + 1, x, v); //x在这个区间的右边，则往下啊判断右子树 t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //通过左右儿子对自己进行更新(前面已经排除没有子节点的情况) &#125; int ask(int p, int l, int r) //节点，待查询的左区间，右区间 &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) return t[p].dat; //如果查询的区间包含节点的区间，直接返回节点的区间 int mid = t[p].l + t[p].r &gt;&gt; 1; //节点区间的中点 int val = -(1 &lt;&lt; 30); //定义负无穷，不会对取最大值造成影响 if(mid &gt;= l) val = max(val, ask(p * 2, l, r)); //如果节点区间中值大于待查询的左边(包含)(空间思考)，搜左子树，进行分治dfs往下搜判断 if(r &gt; mid) val = max(val, ask(p * 2 + 1, l ,r)); // 如果待查询区间在节点区间中点右边(不包含)，搜右子树，进行dfs分治往下搜判断 return val; //返回值， 这个节点对整个区间的贡献 &#125;int main()&#123; build(1, 1, N); //第一个节点，1 —N范围 change(1, 5, 9); //第一个节点，把第五个改为 9 ask(1, 2, 9); //第一个节点，查询2 —9的最值 return 0;&#125; 延迟标记线段树区间查询_spread函数的使用 —add标记支持操作: 区间修改，区间查询和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 1e5 + 10;struct SegmentTree&#123; ll sum, add; //sum为和，add为懒惰标记 // 1.（查询时没有完全覆盖的情况) 即先将值更新左右节点，然后下放用spread()下放add标记，保证递归调用的情况 // 2. 查询时完全覆盖，直接返回当前区间的值（与单点更新版本类似) ,修改时则直接整个区间的sum加上长度 * 修改值d int l, r;&#125;t[N &lt;&lt; 2]; //4倍空间，单点更新中已证明 int a[N], n, m;void build(int p, int l, int r) &#123; t[p].l = l, t[p].r = r; if(l == r) &#123; t[p].sum = a[l]; return ; &#125; //更新到单个点直接对应赋值 int mid = l + r &gt;&gt; 1; build(p &lt;&lt; 1, l , mid); //建左子树区间 build(p &lt;&lt; 1 | 1, mid + 1, r); //建右子树区间 t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; //注意这里是 = 不是 += &#125;void spread(int p) //传递标记的函数 &#123; if(t[p].add) //如果有标记 &#123; //因为最后求得sum是由左右两个区间共同组成，所以先下传add标记(节点所代表的区间完全被覆盖除外, 此时不需要使用左右子树，但是要记录add标记，以后方便使用) t[p &lt;&lt; 1].sum += (ll)t[p].add * (t[p &lt;&lt; 1].r - t[p &lt;&lt; 1].l + 1); //左子树(区间)值更新 t[p &lt;&lt; 1 | 1].sum += (ll)t[p].add * (t[p &lt;&lt; 1 | 1].r - t[p &lt;&lt; 1 | 1].l + 1); //右子树(区间)值更新 t[p &lt;&lt; 1].add += t[p].add; //标记传给左子树 t[p &lt;&lt; 1 | 1].add += t[p].add; //标记传给右子树 t[p].add = 0; //下传标记结束，父亲节点的标记清除 &#125;&#125;void change(int p, int l, int r, int d) //d为待改变的数值 &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) //完全覆盖 &#123; t[p].sum += (ll)d * (t[p].r - t[p].l + 1); //直接整个区间(左端点 - 右端点 + 1)更新 t[p].add += d; //进行标记，便于访问子节点使用 return ; &#125; spread(p); //由于要访问子节点 int mid = t[p].r + t[p].l &gt;&gt; 1; //取节点区间的左右节点 if(mid &gt;= l) change(p &lt;&lt; 1, l, r , d); //子节点中间 &gt;= 查询区间左端点，去左子节点里去访问存在的区间 if(mid &lt; r) change(p &lt;&lt; 1 | 1, l ,r , d); //子节点中间 &lt; 查询区间右端点, 去右子节点里访问存在的区间 t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; //节点和由左右子节点和更新 &#125;ll ask(int p, int l, int r)&#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) return t[p].sum; //如果全部包含，直接返回值(不需要下传标记) spread(p); //没有完全覆盖，需要在左右子节点查询 int mid = t[p].l + t[p].r &gt;&gt; 1; ll val = 0; if(mid &gt;= l) val += ask(p &lt;&lt; 1, l, r); //同上，左右子节点里查询 if(mid &lt; r) val += ask(p &lt;&lt; 1 | 1, l, r); return val;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;a[i]); build(1, 1, n); //建树，下标从1开始，方便对应 p &lt;&lt; 1 和 p &lt;&lt; 1 | 1 的左子节点和右子节点 while(m --) &#123; int l, r, d; char op[2]; //输入格式, 用字符串类型 scanf("%s%d%d", op, &amp;l, &amp;r); if(op[0] == 'C') &#123; scanf("%d", &amp;d); change(1, l, r, d); //区间改值 &#125; else printf("%lld\n", ask(1, l, r)); //询问区间和 &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown示范]]></title>
    <url>%2F2019%2F04%2F16%2F2%2F</url>
    <content type="text"><![CDATA[一级二级三级 列表1 列表2 a 子列表 b 子列表 列表3百度字体是线的哦字体是加粗了的 &lt;html&gt;&lt;/html&gt; 1#include 内容是引用的 $sum$ 12345678910111213141516171819# 一级## 二级### 三级***---***----------- 列表1- 列表2 a 子列表 b 子列表- 列表3 [百度](https://www.baidu.com) ![新客站]() *字体是线的哦* **字体是加粗了的** `&lt;html&gt;&lt;/html&gt;` #include 12&gt; 内容是引用的]]></content>
      <categories>
        <category>语法使用</category>
      </categories>
      <tags>
        <tag>公式语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[耍杂技的牛]]></title>
    <url>%2F2019%2F04%2F16%2F1%2F</url>
    <content type="text"><![CDATA[农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。 奶牛们不是非常有创意，只提出了一个杂技表演： 叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。 奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。 这N头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度Si。 一头牛只撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。 您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。 输入格式第一行输入整数N，表示奶牛数量。 接下来N行，每行输入两个整数，表示牛的重量和强壮程度，第i行表示第i头牛的重量Wi以及它的强壮程度Si。 输出格式输出一个整数，表示最大风险值的最小可能值。 数据范围1≤N≤50000,1≤Wi≤10,000,1≤Si≤1,000,000,000 输入样例：1234310 32 53 3 输出样例：12 (贪心)思路: 与国王游戏的贪心策略相似， 我们先分析每头牛的危险值 = 他前面牛的w(重量值)和 - 自身的s(强壮值)，要使每头牛的危险值最小，这显然是与w 和 s同时相关，所以先 yy 出一种做法按 每头牛的w + s进行升序排序(题见多了可能就会有这种题感)。接下来进行数学分析证明: 牛 交换前 交换后 $i$ $$\sum_{j=1}^{i-1} w_j - s_i$$ $$\sum_{j=1}^{i-1} w_j + w_{i+1}- s_i$$ $i + 1$ $$\sum_{j=1}^{i} w_j - s_{i+1}$$ $$\sum_{j=1}^{i-1} w_j - s_{i+1}$$ 其他牛的危险值显然不变，所以分析交换前后这两头牛中最大的危险值即可。将上述式子进行化简，每个式子减去 $\sum_{j=1}^{i-1} w_j$得到如下式子 牛 交换前 交换后 $i$ $$-s_i$$ $$w_{i+1}- s_i$$ $i + 1$ $$w_i- s_{i+1}$$ $$- s_{i+1}$$ 由于s, w都是正数，$w_i- s_{i+1} &gt; - s_{i+1}$ , $w_{i+1}- s_i &gt; -s_i$ 比较$ w_i- s_{i+1}$, $w_{i+1}- s_i$即可 当$w_i- s_{i+1} &gt;= w_{i+1}- s_i$，即 $w_i + s_i &gt;= w_{i+1} + s_{i+1}$时, 交换后更优 当$w_i- s_{i+1} &lt; w_{i+1}- s_i$，即 $w_i + s_i &lt; w_{i+1} + s_{i+1}$时, 交换前更优 所以得到做法: 按每头牛的 w + s 进行排序, 当存在逆序时就进行交换(即升序排序)，然后根据题意算出每头牛的危险值记录其中的最大值即可代码:1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;const int N = 5e4 + 5;PII a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); a[i].first = x + y; a[i].second = y; &#125; sort(a, a + n); ll res = -1e18, sum = 0; for(int i = 0; i &lt; n; i ++ ) &#123; sum -= a[i].second; res = max(res, sum); sum += a[i].first; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
