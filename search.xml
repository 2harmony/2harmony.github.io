<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二分图判定(染色法)]]></title>
    <url>%2F2019%2F06%2F03%2F31%2F</url>
    <content type="text"><![CDATA[给定一个n个点m条边的无向图，图中可能存在重边和自环。 请你判断这个图是否是二分图。 输入格式第一行包含两个整数n和m。 接下来m行，每行包含两个整数u和v，表示点u和点v之间存在一条边。 输出格式如果给定图是二分图，则输出“Yes”，否则输出“No”。 数据范围1≤n,m≤105 输入样例：123454 41 31 42 32 4 输出样例：Yes 思路如果存在奇数环则不能成为二分图，使用dfs进行搜索判定 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010, M = 200010;int n, m;int h[N], e[M], ne[M], idx;int color[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;bool dfs(int u, int c)&#123; color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!color[j]) //没被染过色 &#123; if (!dfs(j, 3 - c)) return false; //对相邻点染反色，不成功则返回false &#125; else if (color[j] == c) return false; //相邻点已经染色且相同则返回false &#125; return true;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); add(a, b), add(b, a); &#125; bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (!color[i]) &#123; if (!dfs(i, 1)) &#123; flag = false; break; &#125; &#125; if (flag) puts("Yes"); else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单向链表(数组模拟)]]></title>
    <url>%2F2019%2F05%2F30%2F29%2F</url>
    <content type="text"><![CDATA[实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种： (1) “H x”，表示向链表头插入一个数x。 (2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。 (3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式共一行，将整个链表从头到尾输出。 数据范围1≤M≤100000所有操作保证合法。 输入样例：123456789101110H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例：6 4 6 5 解题思路：基本含义: idx表示节点下标，ne[idx] 指向下一个节点，e[idx]表示这个节点的权值, head为头节点，head = -1表示头节点指向空插入操作: 插入坐标为k，值为x的点(在头节点右边插入)：e[idx] = x, ne[idx] = h[u]指向原来头节点指向的点, h[u] = idx ++ 头节点指向新加入的下标为idx点;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int e[100005], ne[100005], head, idx;void init()&#123; idx = 0, head = -1;&#125;void insert_h(int x)&#123; e[idx] = x, ne[idx] = head, head = idx ++ ;&#125; void remove(int x) //指向这个点(下一个点指向的点)&#123; ne[x] = ne[ne[x]];&#125;void insert_x(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;&#125;int main()&#123; init(); int m, x, k; cin &gt;&gt; m; while(m -- ) &#123; char op; scanf(" %c", &amp;op);++++ if(op == 'H') &#123; scanf("%d", &amp;x); insert_h(x); &#125; else if(op == 'D') &#123; scanf("%d", &amp;k); if(!k) head = ne[head]; else remove(k - 1); &#125; else &#123; scanf("%d %d", &amp;k, &amp;x); insert_x(k - 1, x); //下标对应 &#125; &#125; for(int i = head; ~i ; i = ne[i]) //遍历链表 printf("%d ", e[i]); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双链表(数组模拟)]]></title>
    <url>%2F2019%2F05%2F28%2F30%2F</url>
    <content type="text"><![CDATA[实现一个双链表，双链表初始为空，支持5种操作： (1) 在最左侧插入一个数； (2) 在最右侧插入一个数； (3) 将第k个插入的数删除； (4) 在第k个插入的数左侧插入一个数； (5) 在第k个插入的数右侧插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式第一行包含整数M，表示操作次数。 接下来M行，每行包含一个操作命令，操作命令可能为以下几种： (1) “L x”，表示在链表的最左端插入数x。 (2) “R x”，表示在链表的最右端插入数x。 (3) “D k”，表示将第k个插入的数删除。 (4) “IL k x”，表示在第k个插入的数左侧插入一个数。 (5) “IR k x”，表示在第k个插入的数右侧插入一个数。 输出格式共一行，将整个链表从左到右输出。 数据范围1≤M≤100000所有操作保证合法。 输入样例：123456789101110R 7D 1L 3IL 2 10D 3IL 2 7L 8R 9IL 4 7IR 2 2 输出样例：8 7 7 3 2 9 代码 + 思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;const int N = 100005;int l[N], r[N], e[N], idx;void init()&#123; r[0] = 1, l[1] = 0; //0节点右边指向1节点，1节点左边指向0节点 idx = 2; //0 1节点已使用，从2节点开始&#125;void add(int x, int a)&#123; e[idx] = a, l[idx] = x, r[idx] = r[x]; //e存值，(l)新节点指向x，(r)新节点指向(r)原本节点(x) l[r[x]] = idx, r[x] = idx ++ ; //(l)&#123;(r)x节点指向的点&#125; 指向新节点， (r)x指向新节点，idx ++, 变为下一个新节点&#125;void remove(int x) //跳过x点将l(x)和(x)的两节点联系在一起&#123; l[r[x]] = l[x]; //l(r(x))指向l(x) r[l[x]] = r[x]; //r(l(x))指向r(x)&#125;int main()&#123; int m, x, a; cin &gt;&gt; m; init(); while(m -- ) &#123; string op; cin &gt;&gt; op &gt;&gt; x; if(op == "L") add(0, x); else if(op == "R") add(l[1], x); else if(op == "D") remove(x + 1); else if(op == "IL") &#123; cin &gt;&gt; a; add(l[x + 1], a); &#125; else &#123; cin &gt;&gt; a; add(x + 1, a); &#125; &#125; for(int i = r[0]; i != 1; i = r[i]) //遍历 printf("%d ", e[i]); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂模板]]></title>
    <url>%2F2019%2F05%2F28%2F28%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Mat&#123; ll a[105][105];&#125;m, e;ll n, k;const ll mod = 1e9 + 7;Mat mul(Mat a, Mat b)&#123; Mat ans; for(int i = 1; i &lt;= n; i ++ ) //矩阵的初始化 for(int j = 1; j &lt;= n; j ++ ) ans.a[i][j] = 0; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) for(int k = 1; k &lt;= n; k ++ ) ans.a[i][j] = (ans.a[i][j] + a.a[i][k] * b.a[k][j] % mod) % mod; return ans;&#125;Mat qsm(Mat a, ll k) //a变成了矩阵，与普通ksm类似，传结构体&#123; Mat ans = e; while(k) &#123; if(k &amp; 1) ans = mul(ans, a); a = mul(a, a); k &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) cin &gt;&gt; m.a[i][j]; for(int i = 1; i &lt;= n; i ++ ) //单位矩阵，左上到右下对角线为1 e.a[i][i] = 1; Mat res = qsm(m, k); for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) &#123; printf("%lld", res.a[i][j]); j != n ? printf(" ") : printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可达性统计]]></title>
    <url>%2F2019%2F05%2F20%2F27%2F</url>
    <content type="text"><![CDATA[给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。 输入格式第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。 输出格式输出共N行，表示每个点能够到达的点的数量。 数据范围1≤N,M≤30000 输入样例：123456789101110 103 82 32 55 95 92 33 94 82 104 9 输出样例：123456789101633211111 解题思路本题需要进行拓扑排序，f[i]表示第i个点能到的所有点, 最后倒序先统计入度大的点能到达点的数目 代码实现:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;bitset&gt;using namespace std;const int N = 30005;int to[N], h[N], idx;int n, m, d[N], se[N], ne[N], k;bitset&lt;N&gt; f[N]; //bitset32位优化void add(int u, int v)&#123; to[idx] = v, ne[idx] = h[u], h[u] = idx ++;&#125;void topsort()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i ++ ) if(d[i] == 0) //初始入度为0入队 q.push(i); k = 0; while(q.size()) &#123; int u = q.front(); q.pop(); se[++ k] = u; for(int i = h[u]; ~i; i = ne[i]) &#123; int j = to[i]; if(-- d[j] == 0) //相邻点入度为0入队 q.push(j); &#125; &#125;&#125;int main()&#123; memset(h, -1, sizeof(h)); int u, v; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++ ) &#123; cin &gt;&gt; u &gt;&gt; v; add(u, v); d[v] ++; &#125; topsort(); for(int i = k; i &gt;= 1; i -- ) &#123; int t = se[i]; f[t][t] = 1; //自身到自身为1 for(int j = h[t]; ~j; j = ne[j]) f[t] |= f[to[j]]; &#125; for(int i = 1; i &lt;= n; i ++ ) cout &lt;&lt; f[i].count() &lt;&lt; endl; //f[i].count()直接统计1的个数 return 0;&#125;]]></content>
      <categories>
        <category>算竞指南</category>
      </categories>
      <tags>
        <tag>拓步排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索模板 & 拓扑排序]]></title>
    <url>%2F2019%2F05%2F03%2F26%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178// 深度优先遍历框架void dfs(int x) &#123; v[x] = 1; for (int i = head[x]; i; i = next[i]) &#123; int y = ver[i]; if (v[y]) continue; dfs(y); &#125;&#125;// DFS序void dfs(int x) &#123; a[++m] = x; v[x] = 1; for (int i = head[x]; i; i = next[i]) &#123; int y = ver[i]; if (v[y]) continue; dfs(y); &#125; a[++m] = x;&#125;// 求树中各点的深度void dfs(int x) &#123; v[x] = 1; for (int i = head[x]; i; i = next[i]) &#123; int y = ver[i]; if (v[y]) continue; // 点y已经被访问过了 d[y] = d[x] + 1; dfs(y); &#125;&#125;// 求树的重心void dfs(int x) &#123; v[x] = 1; size[x] = 1; // 子树x的大小 int max_part = 0; // 删掉x后分成的最大子树的大小 for (int i = head[x]; i; i = next[i]) &#123; int y = ver[i]; if (v[y]) continue; // 点y已经被访问过了 dfs(y); size[x] += size[y]; max_part = max(max_part, size[y]); &#125; max_part = max(max_part, n - size[x]); if (max_part &lt; ans) &#123; ans = max_part; pos = x; &#125;&#125;//求树的重心#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 4, M = 2 * N;int h[N], to[M], ne[M], idx;int n, ans = 1000000;bool v[N];void add(int u, int v)&#123; to[idx] = v, ne[idx] = h[u], h[u] = idx ++;&#125;int dfs(int u)&#123; v[u] = true; int sum = 0, size = 0; for(int i = h[u]; ~i; i = ne[i]) &#123; int j = to[i]; if(v[j]) continue; int s = dfs(j); size = max(size, s); //求以u为根节点的每个森林的最大大小(节点数) sum += s; //以u为节点除u的树，节点数 &#125; size = max(size, n - sum - 1); //剩下的联通部分 ans = min(size, ans); //最大子块求最小 return sum + 1; //加上u即为以u为根的树&#125; int main()&#123; int u, v; cin &gt;&gt; n; memset(h, -1, sizeof(h)); for(int i = 0; i &lt; n - 1; i ++ ) &#123; cin &gt;&gt; u &gt;&gt; v; add(u, v), add(v, u); &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;// 划分图的连通块void dfs(int x) &#123; v[x] = cnt; for (int i = head[x]; i; i = next[i]) &#123; int y = ver[i]; if (v[y]) continue; dfs(y); &#125;&#125;for (int i = 1; i &lt;= n; i++) if (!v[i]) &#123; cnt++; dfs(i); &#125;// 广度优先遍历框架void bfs() &#123; memset(d, 0, sizeof(d)); queue&lt;int&gt; q; q.push(1); d[1] = 1; while (q.size()) &#123; int x = q.front(); q.pop(); for (int i = head[x]; i; i = next[i]) &#123; int y = ver[i]; if (d[y]) continue; d[y] = d[x] + 1; q.push(y); &#125; &#125;&#125;// 拓扑排序void add(int x, int y) // 在邻接表中添加一条有向边&#123; ver[++tot] = y, next[tot] = head[x], head[x] = tot; deg[y]++;&#125;void topsort() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) if (deg[i] == 0) q.push(i); while (q.size()) &#123; int x = q.front(); q.pop(); a[++cnt] = x; for (int i = head[x]; i; i = next[i]) &#123; int y = ver[i]; if (--deg[y] == 0) q.push(y); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; // 点数、边数 for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); add(x, y); &#125; topsort(); for (int i = 1; i &lt;= cnt; i++) printf("%d ", a[i]); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>搜索模板 &amp; 拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典trie模板]]></title>
    <url>%2F2019%2F05%2F02%2F24%2F</url>
    <content type="text"><![CDATA[标准版含义详解a[p][ch]的值为下一个节点的层数，即idx(第几个节点)，ch为字符指针配合p即可确定节点所在的具体层数与位置(N为所有字符串总长度，每层26个节点)a[p][ch]第一维共N 26个节点， idx最大为N 26 - 1通过 p = a[p][ch]来实现更新指向下一个节点12345678910111213141516171819202122232425262728const int N = ;int a[N][26], idx; //根节点在第0层 char str[N];bool end[N]; //结束数组(在最后一个元素下一层)void insert()&#123; int p = 0; //根节点为 0， p为在树中的层数 for(int i = 0; str[i]; i ++ ) &#123; char ch = str[i] - 'a'; //ch为字符指针 if(!a[p][ch]) a[p][ch] = ++ idx; //字符指针指向空，创建节点(a[p][ch]的值为下一层，即字符指针指向的地方)，新节点 p = a[p][ch]; //变换到下一个节点(下一层) &#125; end[p] = true; //结束标记，下一层的位置标记true &#125;bool search()&#123; int p = 0; //根节点，p为层数 for(int i = 0; str[i]; i ++ ) &#123; char ch = str[i] - 'a'; //字符指针 if(!a[p][ch]) return false; //指向空，返回false p = a[p][ch]; //节点变换到下一个(下一层) &#125; return end[p]; //整个字符串成功便利，判断是否有结束标记 &#125; 例题一: 前缀统计给定N个字符串S1,S2…SN，接下来进行M次询问，每次询问给定一个字符串T，求S1～SN中有多少个字符串是T的前缀。 输入字符串的总长度不超过106，仅包含小写字母。 输入格式第一行输入两个整数N，M。 接下来N行每行输入一个字符串Si。 接下来M行每行一个字符串T用以询问。 输出格式对于每个询问，输出一个整数表示答案。 每个答案占一行。 输入样例：1234563 2abbcabcabcefg 输出样例：1220 题意分析对前n个字符串进行建树，即插入树的insert()操作，对于后m个字符进行search()操作, 判断每个给出的字符串str在n中有多少个为str的前缀。细节处理end[p] -&gt; 变为cnt[p]，从0 1变为统计次数，查询时sum += cnt[p], 遇到a[p][ch]指向空则break退出for循环后 return sum 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 500000, M = 1000010;int a[N][26], idx, cnt[N];char str[N];void insert()&#123; int p = 0; for(int i = 0; str[i]; i ++ ) &#123; int ch = str[i] - 'a'; if(!a[p][ch]) a[p][ch] = ++ idx; p = a[p][ch]; &#125; cnt[p] ++; //变为统计次数&#125;int search()&#123; int p = 0, sum = 0; for(int i = 0; str[i]; i ++ ) &#123; int ch = str[i] - 'a'; if(!a[p][ch]) break; //没查询到，退出返回，可能为0或正数 p = a[p][ch]; sum += cnt[p]; &#125; return sum;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; while(n -- ) //前n个插入操作 scanf("%s", str), insert(); while(m -- ) //后m个查询n中有多少个为str的前缀 &#123; scanf("%s", str); cout &lt;&lt; search() &lt;&lt; endl; &#125; return 0;&#125; 例题二: 最大异或对在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？ 输入格式第一行输入一个整数N。 第二行输入N个整数A1～AN。 输出格式输出一个整数表示答案。 数据范围1≤N≤105,0≤Ai&lt;231 输入样例：1231 2 3 输出样例：3 题意分析将每个A_i视为一个31位的01串，对这n个数进行建树依次insert($A_i$)，共有N * 32个节点，每个节点为0 1其中之一之后对每个串进行查询操作，由于是异或，则应每次判断是否存在num相异的节点，存在则 p = a[p][!num]更新，res对应位变为1(xor相异结果为true)不存在则按原来更新p = a[p][num], 但res此时对应位不做改变 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 100005;int trie[N * 32][2], a[N], idx; //共可能存在N * 32个节点，每个节点0 1两种情况, idx为节点下标void insert(int x) //建树(插入)&#123; int p = 0; for(int i = 30; ~i; i -- ) //从高位到低位遍历0 1串 &#123; int num = x &gt;&gt; i &amp; 1; if(!trie[p][num]) trie[p][num] = ++ idx; p = trie[p][num]; &#125;&#125;int search(int x) //查询&#123; int p = 0, res = 0; for(int i = 30; ~i; i -- ) &#123; int num = x &gt;&gt; i &amp; 1; if(trie[p][!num]) //查询反向num值节点是否存在 p = trie[p][!num], res |= 1; else p = trie[p][num]; //不存在则原样更新 if(i) res &lt;&lt;= 1; //每次向左挪一位 &#125; return res;&#125;int main()&#123; int n, x, ans = 0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; scanf("%d", &amp;a[i]); insert(a[i]); &#125; for(int i = 0; i &lt; n; i ++ ) ans = max(ans, search(a[i])); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>字典trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zyb的面试 - HDU - 6468]]></title>
    <url>%2F2019%2F05%2F02%2F25%2F</url>
    <content type="text"><![CDATA[今天zyb参加一场面试,面试官听说zyb是ACMer之后立马抛出了一道算法题给zyb:有一个序列,是1到n的一种排列,排列的顺序是字典序小的在前,那么第k个数字是什么?例如n=15,k=7, 排列顺序为1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9;那么第7个数字就是15.那么,如果你处在zyb的场景下,你能解决这个问题吗? InputT组样例(T&lt;=100)两个整数n和k(1&lt;=n&lt;=1e6,1&lt;=k&lt;=n),n和k代表的含义如上文 Output输出1-n之中字典序第k小的数字 Sample Input115 7 Sample Output15 解题思想对于这题来说，是一个数位问题，第一想法是数位dp或者全转字符串再按字典序排序(~然而都想复杂了~)注意到一个树下面最多会产生10个子树，又是字典序搜，联想到dfs，如果是bfs那就是正常的数字序.子树实现 利用for循环10种情况 定义一个新的变量, 不会影响来扩展的10种情况的原情况 细节处理 如果找到答案,标记flag = 1, 在每次dfs开头判断,如果找到,后面的操作不必要进行, 相当于结束递归剩下的函数全部出栈123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int n, k, ans, flag, step;void dfs(int x)&#123; if(flag) return ; //找到答案, 剩余函数全出栈 if(step == k) //步数,相等,找到答案 &#123; flag = 1; ans = x; return ; &#125; step ++; for(int i = 0; i &lt;= 9; i ++ ) //10个分支情况子树, 利用for循环实现 &#123; int u = x * 10 + i; //注意利用u来实现不影响10种情况的来源 if(u &gt; n) return ; //即时判断 dfs(u); //搜子情况 &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; flag = 0, step = 1; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= 9; i ++ ) //从1 ~ 9开始搜, 区别于上面的 * 10 + i, 但也满足找到答案直接出栈. dfs(i); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邻接表]]></title>
    <url>%2F2019%2F04%2F29%2F22%2F</url>
    <content type="text"><![CDATA[邻接表存图思想将每个节点作为一个表头，构建了n个单链表1234567891011int n, m, tot; //n个点，m条边，tot为边的个数int edge[M], ver[M], Next[M]; //边权值，顶点，接着的边（tot序号）int d[N], head[N]; //每个点的最短距离，链表头bool v[N]; //访问标记void add(int x, int y, int z) //起点，终点，边权值&#123; ver[++ tot] = y; //终点 edge[tot] = z; //这个边的边权值 Next[tot] = head[x]; //由于从链表头开始插入，则表头存这个边的序号 head[x] = tot; //这边链接的下一个连接原来的表头，最后传递遍历到0，表示结束&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kmp模板 & 最小表示法]]></title>
    <url>%2F2019%2F04%2F29%2F23%2F</url>
    <content type="text"><![CDATA[KMP 模式匹配时间复杂度：O(N + M)求A是否为B的子串，并求出每次出现的匹配位置 1.求Next数组对字符串A求自身匹配，求出Next数组，其中Next[i]表示A中以i为结尾(以i为后缀)的非前缀子串与A的前缀能匹配的最大长度即：Next[i] = max{j}, 其中i &lt; j 且 a[i - j + 1 ~ i] = a[1 ~ j]hint: 当不存在这样的j时 令Next[i] = 0; 步骤 初始化Next[1] = j = 0, 假设Next[1 ~ i - 1]已求出，下面求解Next[i] 利用前面的Next[1 ~ i - 1]进行状态转移，递推求Next[i])，不断尝试扩展匹配长度，如果扩展失败(下一个字符不相等)，令j = Nextj，直至j为0(应该从头开始重新匹配) 如果能扩展成功，匹配长度j ++。 Next[i]的值就是j 123456789101112char a[N], char b[M]; int Next[N]; void get_next()&#123; next[1] = 0; for(int i = 2, j = 0; i &lt;= n; i ++ ) &#123; while(j &gt; 0 &amp;&amp; a[i] != a[j + 1]) j = Next[j]; if(a[i] == a[j + 1]) j ++; Next[i] = j; &#125;&#125; 2.求f[]匹配数组类似于Next[]数组的求法, 当j == n时需要 j = Next[j], 此时要缩短匹配的长度,因为a[j]已经匹配越界 12345678910void get_f()&#123; for(int i = 1, j = 0; i &lt;= m; i ++ ) &#123; while(j &gt; 0 &amp;&amp; (j == n || b[i] != a[j + 1])) j = Next[j]; //j == n a[]边界溢出的情况 if(b[i] == a[j + 1]) j ++; f[i] = j; if(f[i] == n) //即A在B中的某一次出现 &#125;&#125; 最小表示法B[i]表示从i开始的循环同构字符串，即 s[i ~ n] + s[1 ~ i - 1] 算法概述:求出一个字符串的旋转表示里的最小表示(将前缀接到后缀或后缀接到前缀) 思路详解&lt; 将字符串进行二倍扩展, 初始化i = 1, j = 2 通过直接向后扫描, 比较B[i] 与 b[j]两个循环同构串初始k - 0, k ++ 代表向后匹配 k == n 则S只有一种字符构成, 任意B[i]都是最小表示 在 i + k处匹配失败若 s[i + k] &gt; s[j + k] i += k + 1若 s[i + k] &lt; s[j + k] j += k + 1若 i == j 则 i ++ 或 j ++ 即可3.i &gt; n || j &gt; n B[min(i, j)]即为最小表示, 否则重复第2步&lt; 1234567891011121314151617int a[2 * n]; //二倍int get_min()&#123; int n = strlen(s + 1); memcpy(s + n + 1, s + 1, n); //复制成为双倍串 int i = 1, j = 2, k; //i, j不能同位,至少错一位 while(i &lt;= n &amp;&amp; j &lt;= n) &#123; for(k = 0; k &lt; n &amp;&amp; s[i + k] == s[j + k]; k ++ ); //尝试向后匹配 if(k == n) break; if(s[i + k] &gt; s[j + k]) i += k + 1; else j += k + 1; if(i == j) i ++; &#125; int res = min(i, j); //i, j其中 &lt;= n的为最小 return res;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>kmp &amp; 最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[棋盘]]></title>
    <url>%2F2019%2F04%2F27%2F21%2F</url>
    <content type="text"><![CDATA[题目描述有一个m×m的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。 任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 11个金币。 另外， 你可以花费 22 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。 现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？ 输入输出格式输入格式：第一行包含两个正整数m,n，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。 接下来的n行，每行三个正整数x,y,c， 分别表示坐标为(x,y)的格子有颜色cc。 其中c=1 代表黄色，c=0 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为(1,1)，右下角的坐标为(m,m)。 棋盘上其余的格子都是无色。保证棋盘的左上角，也就是(1,1) 一定是有颜色的。 输出格式：一个整数，表示花费的金币的最小值，如果无法到达，输出−1−1。 输入输出样例输入样例#1：123456785 71 1 01 2 02 2 13 3 13 4 04 4 15 5 0 输出样例#1：8 输入样例#2：1234565 51 1 01 2 02 2 13 3 15 5 0 输出样例#2：-1 说明输入输出样例 1 说明 从(1,1)(1,1)开始，走到(1,2)(1,2)不花费金币 从(1,2)(1,2)向下走到(2,2)(2,2)花费 11 枚金币 从(2,2)(2,2)施展魔法，将(2,3)(2,3)变为黄色，花费 22 枚金币 从(2,2)(2,2)走到(2,3)(2,3)不花费金币 从(2,3)(2,3)走到(3,3)(3,3)不花费金币 从(3,3)(3,3)走到(3,4)(3,4)花费 11 枚金币 从(3,4)(3,4)走到(4,4)(4,4)花费 11 枚金币 从(4,4)(4,4)施展魔法，将(4,5)(4,5)变为黄色，花费22 枚金币， 从(4,4)(4,4)走到(4,5)(4,5)不花费金币 从(4,5)(4,5)走到(5,5)(5,5)花费 11 枚金币 共花费 88枚金币。 输入输出样例 2 说明 从(1,1)(1,1)走到(1,2)(1,2),不花费金币 从(1,2)(1,2)走到(2,2)(2,2),花费11金币 施展魔法将(2,3)(2,3)变为黄色,并从(2,2)(2,2)走到(2,3)(2,3)花费22 金币 从(2,3)(2,3)走到(3,3)(3,3)不花费金币 从(3,3)(3,3)只能施展魔法到达(3,2),(2,3),(3,4),(4,3)(3,2),(2,3),(3,4),(4,3)而从以上四点均无法到达(5,5)(5,5),故无法到达终点,输出−1−1数据规模与约定对于 30%30%的数据, 1≤m≤5,1≤n≤101≤m≤5,1≤n≤10。 对于 60%60%的数据, 1≤m≤20,1≤n≤2001≤m≤20,1≤n≤200。 对于 100%100%的数据, 1≤m≤100,1≤n≤1,0001≤m≤100,1≤n≤1,000。]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子序和(单调队列)]]></title>
    <url>%2F2019%2F04%2F25%2F20%2F</url>
    <content type="text"><![CDATA[输入一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。 输入格式第一行输入两个整数n,m。 第二行输入n个数，代表长度为n的整数序列。 同一行数之间用空格隔开。 输出格式输出一个整数，代表该序列的最大子序和。 数据范围1≤n,m≤300000 输入样例：126 41 -3 5 1 -2 3 输出样例：7 思想:tips: 求m连续区间内大于某数可以用尺取法。1.这道题利用前缀和将区间加和转化为两点相减问题就转化为了在m之内，求最大纵坐标差。2.利用队列来维护单调性 - 单调队列 先预处理出前缀和，队列里首先入0来处理出边界sum[r] - sum[l - 1],当一个元素入队时，如果sum[i] - q[l] &gt; m，一直出队队首直到相距距离 &lt;= m 更新答案，由于是单调的，则sum[i] - sum[q[l]]是当前最小。 若sum[i] &gt;= sum[q[r]]，则将队尾出队，由于q[0] = 0, 最后会在此停下 新元素入队 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll; //和爆intconst int N = 3e5 + 5;ll s[N]; //前缀和数组int q[N]; //数组模拟队列int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++ ) //前缀和下标一般从1开始 &#123; scanf("%lld", &amp;s[i]); s[i] += s[i - 1]; //预处理前缀和 &#125; int l = 0, r = 0; //队首，队尾 ll ans = 0; for(int i = 1; i &lt;= n; i ++ ) &#123; while(l &lt;= r &amp;&amp; i - q[l] &gt; m) l ++; //挪动队首直到不 &gt; m ans = max(ans, s[i] - s[q[l]]); //更新答案 while(l &lt;= r &amp;&amp; s[i] &lt;= s[q[r]]) r --; //队尾出队维护单调性 q[++ r] = i; //新元素入队 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算竞指南</category>
      </categories>
      <tags>
        <tag>单调数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直方图最大矩形(单调栈)]]></title>
    <url>%2F2019%2F04%2F25%2F19%2F</url>
    <content type="text"><![CDATA[经典版直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1：通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式输入包含几个测试用例。 每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。 然后跟随n个整数h1，…，hn。 这些数字以从左到右的顺序表示直方图的各个矩形的高度。 每个矩形的宽度为1。 同行数字用空格隔开。 当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。 每个数据占一行。 请注意，此矩形必须在公共基线处对齐。 数据范围1≤n≤100000,0≤hi≤1000000000 输入样例：1237 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例：1284000 方法一yxc老师做法对于每一个矩形，去找左右两边能扩展到的最远边界，那么问题就转化为了找两次边界，而单调栈就是找到第一个比它小的元素，栈里存放下标栈内要满足单调性12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 100005;int a[N], l[N], r[N], s[N], n; //初始数组，左右边界，数组模拟栈，数据个数typedef long long ll; //乘积可能爆long longvoid one_side(int b[])&#123; int top = 1; //栈顶指针 a[0] = -1; //哨兵元素，当s[top] == 0时，即前面所有元素比当前要入栈的a[i]大 //此时a[0] == -1 &lt; a[i](最小为0)，处理掉了边界情况b[i] = 1, wid = 1 - 1 + 1 = 1 for(int i = 1; i &lt;= n; i ++ ) &#123; while(a[s[top]] &gt;= a[i]) //删除栈中比a[i]大的元素，保持单调性 top --; b[i] = s[top] + 1; //边界为栈顶 + 1 s[++ top] = i; //新元素入栈 &#125;&#125;int main()&#123; while(cin &gt;&gt; n, n) &#123; for(int i = 1; i &lt;= n; i ++ ) scanf("%d", &amp;a[i]); one_side(l); //找左边界 reverse(a + 1, a + n + 1); //转置找右边界 one_side(r); ll ans = 0; for(int i = 1, j = n ; i &lt;= n; i ++ , j -- ) //左右对应下标运算 ans = max(ans, (ll)a[i] * (n - l[j] + 1 - r[i] + 1)); //都转化为离终点的距离 cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 方法二lyd做法 思想运用单调栈维护每个元素的左边界，利用w[]数组记录每个元素的向右延伸的宽度利用哨兵元素a[n + 1] == 0清空栈内剩余元素，对于每一次出栈，实时更新栈顶元素的值 * 向右延伸最远宽度(width) 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 100005;int a[N], w[N], s[N];int main()&#123; int n, top = 0; while(cin &gt;&gt; n, n) &#123; for(int i = 1; i &lt;= n; i ++ ) scanf("%d", &amp;a[i]); a[n + 1] = 0, top = 0; ll ans = 0; for(int i = 1; i &lt;= n + 1; i ++ ) &#123; if(a[i] &gt; s[top]) //大于栈顶直接入栈，左宽度为1 s[++ top] = a[i], w[top] = 1; else &#123; int width = 0; while(a[i] &lt; s[top]) //出栈顶元素的时候实时更新 &#123; width += w[top]; ans = max(ans, (ll)width * s[top]); top --; &#125; s[++ top] = a[i], w[top] = width + 1; //删完后入栈，前面元素的最远宽度加上本身1作为左宽度 &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 扩展(城市游戏)有一天，小猫rainbow和freda来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。 这片土地被分成N*M个格子，每个格子里写着’R’或者’F’，R代表这块土地被赐予了rainbow，F代表这块土地被赐予了freda。 现在freda要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着’F’并且面积最大。 但是rainbow和freda的OI水平都弱爆了，找不出这块土地，而蓝兔也想看freda卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为S，它们将给你3*S两银子。 输入格式第一行包括两个整数N,M，表示矩形土地有N行M列。 接下来N行，每行M个用空格隔开的字符’F’或’R’，描述了矩形土地。 每行末尾没有多余空格。 输出格式输出一个整数，表示你能得到多少银子，即(3*最大’F’矩形土地面积)的值。 数据范围1≤N,M≤1000 输入样例：1234565 6R F F F F FF F F F F FR R R F F FF F F F F FF F F F F F 输出样例：45 思想：类似于最大子阵和，进行行压缩，枚举每一行作为一维的进行计算 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1005;int h[N][N], n, m;int s[N], wid[N];int work(int a[]) //传入时转化为一维问题&#123; int width, top = 0, ans = 0; a[m + 1] = 0; for(int i = 1; i &lt;= m + 1; i ++ ) &#123; if(a[i] &gt; a[s[top]]) wid[i] = 1, s[++ top] = i; else &#123; width = 0; while(a[i] &lt; a[s[top]]) &#123; width += wid[s[top]]; ans = max(ans, a[s[top -- ]] * width); &#125; wid[i] = width + 1, s[ ++ top] = i; &#125; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; char c; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) &#123; scanf(" %c", &amp;c); if(c == 'F') h[i][j] = h[i - 1][j] + 1; //进行递推，如果有f则为上一行 + 1，否则为0 &#125; int res = 0; for(int i = 1; i &lt;= n; i ++ ) res = max(res, work(h[i])); //二维数组，传入一维地址进行简化 cout &lt;&lt; res * 3 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算竞指南</category>
      </categories>
      <tags>
        <tag>单调数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛法]]></title>
    <url>%2F2019%2F04%2F24%2F18%2F</url>
    <content type="text"><![CDATA[Eratosthenes筛法(实用)时间复杂度: $\sum_{质数 p &lt;= N * {\frac Np}} = O(NloglogN) $ 思想:定义一个bool v数组表示是否是合数对于一个从2开始的整数，它的倍数(从2开始)都将是合数，将其全部筛去，剩下的即是素数。 优化对于一个数x，我们可能多次筛它，那么考虑 直接从$ x^2 $开始筛，因为在$ x^2 $ 之内的数已经被前面$(x - 1) x$筛掉了，所以从 ${x ^ 2} -&gt; {x * k} (k &lt;= n) $123456789101112const int N = 100;int v[N], m; //v为访问数组void primes(int n)&#123; for(int i = 2; i &lt;= n; i ++ ) &#123; if(v[i]) continue; for(int j = i; j &lt;= n / i; j ++ ) //从i^2 开始筛 v[i * j] = 1; &#125;&#125; 线性筛法思想:“从大到小累积质因子” 设数组v记录每个数的最小质因子 方法 若v[i] == 0, 则i是质数(最小质因数是它本身)，记录在prime数组 用每个不大于v[i]的质数p，与i相乘构成新的合数，由于p &lt;= v[i]此时新数的最小质因数为p 时间复杂度分析每个数会被它的最小质因数筛一次, 时间复杂度为 $O(n)$1234567891011121314151617const int N = 100;int v[N], m; //v数组记录每个数的最小质因数int prime[N];void primes(int n)&#123; for(int i = 2; i &lt;= n; i ++ ) &#123; if(!v[i]) //最小质因数是他本身，记录答案 v[i] = i, prime[ ++ m] = i; for(int j = 1; j &lt;= m; j ++ ) //用小于v[i]的p去乘i &#123; if(!(prime[j] &lt;= v[i] &amp;&amp; prime[j] &lt;= n / i)) continue; //p &gt; v[i] 或 p * i &gt; n则退出 v[i * prime[j]] = prime[j]; //最小质因子筛数 &#125; &#125;&#125; 欧拉函数设n分解的质因数形式为$n= a_1^n1 a_2^n2 a_3^n3 …… a_n^n$那么在1-n-1中与n互质的个数为cnt = n (1 – 1 / a1) (1 – 1 / a2) …… * (1 – 1 / an) 1234567891011121314int euler(int n)&#123; int res = n; for(int i = 2; i * i &lt;= res; i ++) &#123; if(n % i == 0) //如果有这个质因数 res = res / i * (i-1); //防止溢出，先除再乘 while(n % i == 0) //除去相同的因子，因为只需一次即可 n /= i;&#125; if(n! = 1) //可能因子超过 根号n res = res / n * (n - 1); //再乘上它的1- 1/num return n;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串hash模板]]></title>
    <url>%2F2019%2F04%2F24%2F17%2F</url>
    <content type="text"><![CDATA[思想将每个字母映射成P进制数，一般进制数取131, 13331, 每个字母a - z相应的映射成 1 - 26, 这个数使用unsigned long long进行2^64的自动取模，避免了低效的mod运算。 求一段序列的hash值令$ “axybb” = 1242522 (1, 24, 25, 2, 2)$求xyb的hash值 $ axy = axyb - a * 123^{( 4 - (2 - 1) )} $, 将a左移进行对齐。 tips可以多取几组p(可以取大质数)进行运算，如果都相等则为同一个串。123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 5;typedef unsigned long long ull; //使用unsigned long long 进行自动溢出取模，减少低效的mod运算ull p = 131, h[N], power[N];char str[N];ull get(int l, int r) //计算子串hash值&#123; return h[r] - h[l - 1] * power[r - l + 1]; //类似于前缀和，则输入时下标从1开始，进行左对齐&#125;int main()&#123; scanf("%s", str + 1); //当l == 1时, l - 1 == 0的边界处理。 power[0] = 1; int n = strlen(str + 1); for(int i = 1; i &lt;= n; i ++ ) &#123; h[i] = h[i - 1] * p + str[i] - 'a' + 1; //p进制转换，ull自动取模 power[i] = power[i - 1] * p; //计算p乘方 &#125; int m, l1, l2, r1, r2; cin &gt;&gt; m; while(m -- ) &#123; scanf("%d %d %d %d", &amp;l1, &amp;r1, &amp;l2, &amp;r2); //两个子串 if(get(l1, r1) == get(l2, r2)) //相等判断 cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>字符串hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集简单应用]]></title>
    <url>%2F2019%2F04%2F23%2F16%2F</url>
    <content type="text"><![CDATA[食物链动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。 A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。 每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是”1 X Y”，表示X和Y是同类。 第二种说法是”2 X Y”，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。 当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。 你的任务是根据给定的N和K句话，输出假话的总数。 输入格式第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。 输出格式只有一个整数，表示假话的数目。 数据范围1≤N≤50000,0≤K≤100000 输入样例：12345678100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5 输出样例：3 思想:由于有a，b，c三种动物，$a -&gt; b$, $b -&gt; c$, $c -&gt; a$，的这种关系，且题设也没告诉具体是哪种物种，所以三种情况全考虑用0 ~ n - 1表示a，n ~ 2 n - 1表示b, 2 n ~ 3 * n - 1表示c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;algorithm&gt;const int MN = 50005;int par[MN * 3], heig[MN * 3]; //初始化3个 int n, k;void init(int n) //并查集模板 &#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x) &#123; if(par[x] == x) return x; return par[x] = find(par[x]); &#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if(x == y) return; if(heig[x] &lt; heig[y]) par[x] = y; else &#123; par[y] = x; if(heig[x] == heig[y]) heig[x] ++; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;using namespace std;int main()&#123; cin &gt;&gt; n &gt;&gt; k; init(n * 3); int ans = 0; while(k --) &#123; int opt, x, y; scanf("%d %d %d", &amp;opt, &amp;x, &amp;y); if(x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n) //越界错误次数即答案+1 &#123; ans ++; continue; &#125; x -- , y --; //由于下标从0开始，-- 对应 if(opt &amp; 1) //第一种操作 "查询是否为同一物种" &#123; if(same(x, y + n) || same(x, y + 2 * n)) //x，y肯定为同一物种，如果x 和y的其它两种状态任意一种在同一个集合中那么就矛盾，ans ++ ans ++; else &#123; unite(x, y); //每个对应的合并，3种情况全部考虑 unite(x + n, y + n); unite(x + 2 * n, y + 2 * n); &#125; &#125; else &#123; if(same(x, y) || same(x, y + 2 * n)) //如果吃同类或者出现a -&gt; c ,b -&gt; a, c -&gt; b的情况就是错误的，即跨两个吃就是已经逆向循环了 ans++; else &#123; unite(x, y + n); //如果是正确的那么就建立起a -&gt; b, b -&gt; c, c -&gt; a的情形 unite(x + n, y + 2 * n); unite(x + n * 2, y); &#125; &#125; &#125; cout &lt;&lt; ans; return 0;&#125; 网络维修电话线公司（TLC）正在建立一个新的电话电缆网络。它们连接了几个由1到N的整数编号的位置。 没有两个地方有相同的号码。线路是双向的，并且总是将两个地方连接在一起， 并且每个地方线路终止于电话交换机。每个地方都有一个电话交换机。它来自每个地方 可以通过线路到达其他地方，但它不需要是直接连接，它可以通过几次间接连接。 有时电源在某个地方发生故障，因而交换机无法运行。 TLC的官员意识到，在这种情况下， 除了故障的地方无法到达的之外，这也可能导致其他地方无法相互连接。 在这种情况下，我们会说地点（故障的地方）是至关重要的。 现在，官员正试图编写一个程序来查找所有这些关键位置的数量。帮助他们。 输入输入文件由几个行块组成。每个块描述一个网络。在每个块的第一行中，存在N &lt;100的位数。 接下来最多N行中的每一行包含一个地点的编号，后面跟有来自该地方的直线的一些地方的编号。 这些最多N行完全描述了网络，即，网络中两个地方的每个直接连接至少包含在一行中。一行中的所有数字都是分开的 一个。每个块以一条仅包含0的行结束。最后一个块只有一行，N = 0; 输出输出包含除输入文件中的最后一个块之外的每个块，其中一行包含关键位置的数量。 样例输入12345675 1 2 3 4062 1 35 4 6 200 样例输出1212 提示您需要确定一行的结尾。为了使其易于确定，在每行结束之前没有多余的空白。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;struct point&#123; //结构体坐标 (使用pair&lt;&gt;型也可) int x, y;&#125;a[N];int n, d;int par[N], rk[N], vis[N]; //父亲节点，高度，访问标记数组 void init() //初始化每个点一个集合，自己为自己的根节点 &#123; for(int i = 1; i &lt;= n; i ++) par[i] = i;&#125;int find(int x) //寻找根节点 &#123; if(x == par[x]) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y) //根据树的高度进行合并 &#123; x = find(x), y = find(y); if(x == y) return ; if(rk[x] &gt; rk[y]) par[y] = x; else &#123; par[x] = y; if(rk[x] == rk[y]) rk[y] ++; &#125;&#125;bool same(int x, int y) //判断是否为一个集合(即根节点是否相同) &#123; return find(x) == find(y);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; d; init(); for(int i = 1; i &lt;= n ;i ++) cin &gt;&gt; a[i].x &gt;&gt; a[i].y; int t = n + 2; char opt; while(cin &gt;&gt; opt) &#123; int p; cin &gt;&gt; p; if(opt == 'O') &#123; vis[p] = 1; for(int i = 1; i &lt;= n; i ++) if(vis[i]) &#123; int dis = (a[p].x - a[i].x) * (a[p].x - a[i].x) + (a[p].y - a[i].y) *( a[p].y - a[i].y); //哈密顿距离小于给定距离并且次点被 //访问过(即修过)就可以进行合并 if(dis &lt;= d * d) unite(p, i); &#125; &#125; else &#123; int q; cin &gt;&gt; q; if(!vis[q] || !vis[p]) cout &lt;&lt; "FAIL\n"; //如果其中有一个没有被访问过 else if(same(q, p)) cout &lt;&lt; "SUCCESS\n"; //如果都访问过且根节点相同 else cout &lt;&lt; "FAIL\n"; //根基点不同 &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归打印图形]]></title>
    <url>%2F2019%2F04%2F19%2F15%2F</url>
    <content type="text"><![CDATA[分形分形，具有以非整数维形式充填空间的形态特征。 通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。 现在，定义“盒子分形”如下： 一级盒子分形： X二级盒子分形：123X X XX X 如果用B(n - 1)代表第n-1级盒子分形，那么第n级盒子分形即为：12345B(n - 1) B(n - 1) B(n - 1)B(n - 1) B(n - 1) 你的任务是绘制一个n级的盒子分形。 输入格式输入包含几个测试用例。 输入的每一行包含一个不大于7的正整数n，代表要输出的盒子分形的等级。 输入的最后一行为-1，代表输入结束。 输出格式对于每个测试用例，使用“X”符号输出对应等级的盒子分形。 请注意’X’是一个大写字母。 每个测试用例后输出一个独立一行的短划线。 输入样例：123451234-1 输出样例1234567891011121314151617181920212223242526272829303132333435363738394041424344X-X X XX X-X X X X X XX X X X X X X X XX X X X X XX X X X-X X X X X X X X X X X XX X X X X X X X X X X X X X X X X XX X X X X X X X X X X XX X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X XX X X X X X X X X X X XX X X X X X X X X X X X X X X X X XX X X X X X X X X X X XX X X X X X X X- 递归 + 递推优化(减少递归的分支数，减小时间复杂度)对于n级来说，只用画 5 个n - 1级，递归终止条件为 n == 1 true时，然后进行回溯，画剩下的4个(由第n级的 n - 1级复制过来)然后往上继续回溯1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;bool a[N][N]; //由于只有画与不画两种状态(要画的只有一种图形)， int qsm(int a, int b) //快速幂，用来计算len的长度 &#123; int res = 1; while(b) &#123; if(b &amp; 1) res *= a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;void dfs(int n) //n级分形的规划 &#123; if(n == 1) //1级直接画 &#123; a[0][0] = true; //先画左上角 return ; &#125; dfs(n - 1); //进行dfs，靠回溯来完善整个图形 int len = qsm(3, n - 2); //长度为n级的n - 1 级(n级由 5 个 n - 1级组成) ，那么表示就会表示为 3 ^ (n - 2) int px[4] = &#123;0, 1, 2, 2&#125;, py[4] = &#123;2, 1, 0, 2&#125;; //n级里的 其它4个n - 1级的开始坐标(左上角) for(int i = 0; i &lt; 4; i ++ ) //4种情况 for(int j = 0; j &lt; len; j ++ ) //i 表示4个 n - 1级的图形，j, k为横纵坐标(为了进行复制) for(int k = 0; k &lt; len; k ++ ) //4种情况，以len为基础 a[j + px[i] * len][k + py[i] * len] |= a[j][k]; //进行"等位"(加上中心偏移量)复制 &#125;int main()&#123; dfs(7); //预先算出答案，空间换时间 int n; while(cin &gt;&gt; n &amp;&amp; n != -1) &#123; int len = qsm(3, n - 1); //每级的长度为3 ^ n - 1 for(int i = 0; i &lt; len; i ++ ) &#123; for(int j = 0; j &lt; len; j ++ ) if(a[i][j]) cout &lt;&lt; 'X'; //1状态输出'X', 否则为' ' else cout &lt;&lt; ' '; puts(""); //记得换行 &#125; cout &lt;&lt; '-' &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算竞指南</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间贪心问题]]></title>
    <url>%2F2019%2F04%2F19%2F14%2F</url>
    <content type="text"><![CDATA[最小区间覆盖题意: 给定m个区间(左右端点)，求最少用多少个区间能覆盖1 - n思想 : 将所有线段按左端点升序排序 另s = 0，用t进行备份，在左端点不超过的s + 1的前提下找到最远的右端点即while(l &lt;= t + 1) s = max(s, r); 更新完后判断if(s &gt;= r)123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#define l first#define r secondusing namespace std;const int N = 1e5 + 5;typedef pair&lt;int, int&gt; PII;PII a[N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++) scanf("%d %d", &amp;a[i].l, &amp;a[i].r); sort(a, a + m); int s = 0, idx = 0, ans = 0, t; while(s &lt; n &amp;&amp; idx &lt; m) &#123; if(a[idx].l &gt; s + 1) &#123; cout &lt;&lt; "-1"; return 0; &#125; t = s; //开始的位置需要备份， 直到左端点大于 t + 1时退出，这时t再进行更新 while(a[idx].l &lt;= t + 1 &amp;&amp; idx &lt; m) &#123; s = max(s, a[idx].r); //得到可选择中的右边点的最远点 idx ++; &#125; ans ++; t = s; &#125; if(s == n) cout &lt;&lt; ans; //是否达到目标 else cout &lt;&lt; "-1"; return 0;&#125; 畜栏预定有N头牛在畜栏中吃草。 每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。 给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。 当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。 求需要的最小畜栏数目和每头牛对应的畜栏方案。 输入格式第1行：输入一个整数N。 第2..N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。 输出格式第1行：输入一个整数，代表所需最小畜栏数。 第2..N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号从1开始，只要方案合法即可。 数据范围1≤N≤50000,1≤A,B≤1000000 输入样例：12345651 102 43 65 84 7 输出样例：123456412324 方法: 按照起点对所有区间进行排序，然后用小顶堆维护一个最小的右区间，如果右区间 &gt;= 新的左区间，说明只能建立一个新的畜栏 小顶堆更新即可如果右区间 &lt; 左区间，说明可以放在最小右区间那一行中，更新小顶堆即可当前最优解为 k证明: 反证法: 假设存在 m &lt; k 为最优解，另处理第m + 1 牛时为 i，由于是按顺序枚举，则m.l &lt;= i.l，枚举第i头牛时会出现 m.r &gt;= i.l的情况则会出现包含的情况， 需要m + 1个围栏，以此类推到最优解k个12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 50000 + 5;typedef pair&lt;int, int&gt; PII;pair&lt;PII, int&gt; cows[N]; //cows[i].second 记录当前的编号 int id[N]; //默认顺序，之后进行排序会打乱 int main()&#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second; cows[i].second = i; &#125; sort(cows + 1, cows + n + 1); //按区间左端点排序 priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; //小顶堆维护最小右区间 for(int i = 1; i &lt;= n; i ++) &#123; if(q.empty() || q.top().first &gt;= cows[i].first.first) //如果为空或最小右区间大于l，则必须加一个围栏 &#123; PII t = &#123;cows[i].first.second, q.size() + 1&#125;; //牛栏编号为i id[cows[i].second] = t.second; //记录编号 q.push(t); //入堆 &#125; else &#123; PII now = q.top(); //和最小右区间一个栅栏 q.pop(); now.first = cows[i].first.second; //右区间会被更新 id[cows[i].second] = now.second; //这个牛也在这个栅栏 q.push(now); //i继续入堆，让其维护最小的右区间 &#125; &#125; cout &lt;&lt; q.size() &lt;&lt; endl; for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; id[i] &lt;&lt; endl; //按输入顺序，顺序输出每头牛 的栅栏编号 return 0;&#125; 区间选点覆盖雷达设备 假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。 每个小岛都位于海洋一侧的某个点上。 雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。 我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。 现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。 输入格式第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。 接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。 同一行数据之间用空格隔开。 输出格式输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。 数据范围1≤n≤1000 输入样例：12343 21 2-3 12 1 输出样例：12 思想方法，先将题目进行转化，由勾股定理转化为区间问题: 给定n个区间，用最少的点数让每个去区间至少包含一个点做法: 先让区间按照右端点进行排序，然后判断当前左区间是否大于 last(右区间) ，如果大于则 ans ++证明: 假设上述选择出来的区间有 m 个，由于右区间按升序排序，且当前左区间大于上一个的右区间，即每条线段都不相交，那么至少需要m个点来被包含1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef pair&lt;double, double&gt; PDD;const double eps = 1e-6; //浮点数比大小 const int N = 1008;PDD p[N];int main()&#123; int n, x, y, d; double len; cin &gt;&gt; n &gt;&gt; d; for(int i = 0; i &lt; n; i ++) &#123; scanf("%d %d", &amp;x, &amp;y); if(d &lt; y) &#123; cout &lt;&lt; "-1"; return 0; &#125; auto len = sqrt(d * d - y * y); //两次使用，一次定义 p[i] = &#123;x + len, x - len&#125;; //转化为线段(利用勾股定理) &#125; sort(p, p + n); //按右端点升序排列 int ans = 0; double last = -1e10; //上一个的右区间，由于第一个线段必定覆盖则定义为 -inf，让第一个必定满足 for(int i = 0; i &lt; n; i ++) if(p[i].second &gt; last + eps) //小于等于不用更新，相减大于eps则满足条件 &#123; ans ++; last = p[i].first; //更新为当前的右区间 &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倒水问题 + bfs模拟]]></title>
    <url>%2F2019%2F04%2F19%2F13%2F</url>
    <content type="text"><![CDATA[HDU1495 非常可乐大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input1237 4 34 1 30 0 0 Sample Output12NO3 思路，根据题意进行模拟，什么情况下可以倒 (6种情况) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int s, n, m, ans;const int N = 101;bool v[N][N][N]; //判重 struct node&#123; int x, y, z, stp; node(int x, int y, int z, int stp) : x(x), y(y), z(z), stp(stp) &#123; &#125; // 3 + 1个状态 &#125;;bool bfs()&#123; queue&lt;node&gt; q; q.push(&#123;s, 0, 0, 0&#125;); v[s][0][0] = 1; while(!q.empty()) &#123; int sum; node t = q.front(); q.pop(); if((t.x == t.y &amp;&amp; t.x == s &gt;&gt; 1) || (t.x == t.z &amp;&amp; t.x == s &gt;&gt; 1) || (t.y == t.z &amp;&amp; t.y == s &gt;&gt; 1)) //平分总量 &#123; ans = t.stp; //记录答案，返回成功 return true; &#125; for(int i = 0; i &lt; 6; i ++ ) //6种情况 A 3 2 ( 3！) switch(i) &#123; case 0: x -&gt; y if(t.x == 0 || t.y == n) //x瓶没有， y瓶满，不能倒 break; sum = t.x + t.y; //类似于pots问题，先记录总量 if(sum &gt;= n) //倒完还剩一点(可能刚好) ，目标壶会倒满 &#123; if(v[sum - n][n][t.z]) break; v[sum - n][n][t.z] = 1; q.push(&#123;sum - n, n, t.z, t.stp + 1&#125;); &#125; else //起始盆倒空，所有倒入目标盘 &#123; if(v[0][sum][t.z]) break; v[0][sum][t.z] = 1; q.push(&#123;0, sum, t.z, t.stp + 1&#125;); &#125; break; case 1: if(t.x == 0 || t.z == m) break; sum = t.x + t.z; if(sum &gt;= m) &#123; if(v[sum - m][t.y][m]) break; v[sum - m][t.y][m] = 1; q.push(&#123;sum - m, t.y, m, t.stp + 1&#125;); &#125; else &#123; if(v[0][t.y][sum]) break; v[0][t.y][sum] = 1; q.push(&#123;0, t.y, sum, t.stp + 1&#125;); &#125; break; case 2: if(t.y == 0 || t.z == m) break; sum = t.y + t.z; if(sum &gt;= m) &#123; if(v[t.x][sum - m][m]) break; v[t.x][sum - m][m] = 1; q.push(&#123;t.x ,sum - m, m, t.stp + 1&#125;); &#125; else &#123; if(v[t.x][0][sum]) break; v[t.x][0][sum] = 1; q.push(&#123;t.x, 0, sum, t.stp + 1&#125;); &#125; case 3: if(t.y == n || t.z == 0) break; sum = t.y + t.z; if(sum &gt;= n) &#123; if(v[t.x][n][sum - n]) break; v[t.x][n][sum - n] = 1; q.push(&#123;t.x , n, sum - n, t.stp + 1&#125;); &#125; else &#123; if(v[t.x][sum][0]) break; v[t.x][sum][0] = 1; q.push(&#123;t.x, sum, 0, t.stp + 1&#125;); &#125; break; case 4: if(t.y == 0 || t.x == s) //向最大壶倒，不可能溢出和留下水 ，全部倒入，自身变 0 break; sum = t.y + t.x; if(v[sum][0][t.z]) break; v[sum][0][t.z] = 1; q.push(&#123;sum, 0, t.z, t.stp + 1&#125;); case 5: if(t.z == 0 || t.x == s) break; sum = t.z + t.x; if(v[sum][t.y][0]) break; v[sum][t.y][0] = 1; q.push(&#123;sum, t.y, 0, t.stp + 1&#125;); &#125; &#125; return false; &#125;int main()&#123; while(scanf("%d %d %d", &amp;s, &amp;n, &amp;m) == 3 &amp;&amp; s) &#123; memset(v, 0, sizeof(v)); if(s &amp; 1) cout &lt;&lt; "NO\n"; //奇数水量无法平分 else if(bfs()) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; "NO\n"; &#125; return 0;&#125; Pots POJ - 3414模拟bfs（涉及最小步数问题) 你有两个罐子，分别有A和B升的体积。可以执行以下操作： FILL（i）把水壶i倒满(1≤i≤2）;DROP（i）把水壶i倒空;POUR（i，j）从锅i倒入锅j;在此操作之后，罐j已满（并且罐i中可能存在一些水），或罐i是空的（并且其所有水已被移动到罐j）。编写一个程序来找到这些操作的最短可能序列，这些操作将在其中一个罐中产生完全C升的水。 输入一行上是数字A，B和C.这些都是1到100之间的整数，并且C≤max（A，B）。 输出输出的第一行必须包含操作序列K的长度。以下K行必须各自描述一个操作。如果有几个最小长度的序列，则输出其中任何一个。如果无法实现所需的结果，则文件的第一行和唯一行必须包含“impossible”一词。 样本输入13 5 4 样本输出12345676FILL（2）POUR（2,1）DROP（1）POUR（2,1）FILL（2）POUR（2,1） 思路6种情况，进行判重，由于每个节点由一个前驱节点转移过来，所以用node pre[N][N]保存前驱节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int a, b, c;const int N = 115;bool v[N][N];vector&lt;int&gt; path; //倒序输出节点 struct node&#123; int x, y, stp; node() &#123; &#125; node(int x, int y, int stp) : x(x), y(y), stp(stp) &#123; &#125;&#125;;node pre[N][N], ans; //保存前驱点 bool bfs()&#123; int sum; queue&lt;node&gt; q; q.push(&#123;0, 0, 0&#125;); v[a][b] = 1; while(!q.empty()) &#123; node t = q.front(); q.pop(); if(t.x == c || t.y == c) &#123; ans = t; return true; &#125; for(int i = 0; i &lt; 6; i ++ ) &#123; node ne = t; switch(i) &#123; case 0: //把x瓶倒满 ne.x = a; break; case 1: ne.y = b; //把y瓶倒满 break; case 2: ne.x = 0; //把x瓶倒空 break; case 3: ne.y = 0; //把y瓶倒空 break; case 4: sum = ne.x + ne.y; //总水量 if(sum &gt;= b) //倒入y中，多余的部分倒入x中 ne.y = b, ne.x = sum - b; else ne.x = 0, ne.y = sum; break; case 5: sum = ne.x + ne.y; if(sum &gt;= a) //倒入x中，多余的部分导入y中 ne.x = a, ne.y = sum - a; else ne.x = sum, ne.y = 0; break; &#125; if(!v[ne.x][ne.y]) //判重，由于每个点只访问一次 &#123; pre[ne.x][ne.y] = &#123;t.x, t.y, i&#125;; q.push(&#123;ne.x, ne.y, t.stp + 1&#125;); &#125; v[ne.x][ne.y] = 1; &#125; &#125; return false;&#125;void print()&#123; cout &lt;&lt; ans.stp &lt;&lt; endl; while(!(ans.x == 0 &amp;&amp; ans.y == 0)) //从终点开始往前找前驱节点直到起点 &#123; int i = pre[ans.x][ans.y].stp; path.push_back(i); ans = pre[ans.x][ans.y]; &#125; reverse(path.begin(), path.end()); //反向找的，逆序回来 for(vector&lt;int&gt; :: iterator i = path.begin(); i &lt; path.end(); i ++) switch(*i) &#123; case 0: //6种情况对应输出 cout &lt;&lt; "FILL(1)\n"; break; case 1: cout &lt;&lt; "FILL(2)\n"; break; case 2: cout &lt;&lt; "DROP(1)\n"; break; case 3: cout &lt;&lt; "DROP(2)\n"; break; case 4: cout &lt;&lt; "POUR(1,2)\n"; break; case 5: cout &lt;&lt; "POUR(2,1)\n"; break; &#125;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(bfs()) print(); else cout &lt;&lt; "impossible\n" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N 皇后问题 HDU - 2553]]></title>
    <url>%2F2019%2F04%2F19%2F12%2F</url>
    <content type="text"><![CDATA[在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input12341850 Sample Output12319210 思想:按行枚举，每一行只能放一个皇后，三个标记变量，v[0]-列，v[1]-左下对角线，v[2]-右上对角线 ，表示这个地方是否被占 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 15;int a[N][N], pos[N];bool v[3][N * 3]; int n, cnt;void print() //打印结果函数 &#123; for(int i = 0; i &lt; n; i ++ ) &#123; for(int j = 0; j &lt; n; j ++ ) &#123; if(pos[i] == j) //找到每行所放的皇后位置 cout &lt;&lt; 'X'; else cout &lt;&lt; 'O'; &#125; cout &lt;&lt; '\n'; &#125; puts("");&#125;void dfs(int k)&#123; if(k == n) //放到第n行，即皇后全部放完，记录答案，打印 &#123; cnt ++; print(); return ; &#125; for(int i = 0; i &lt; n; i ++ ) &#123; if(!v[0][i] &amp;&amp; !v[1][k + i] &amp;&amp; !v[2][k - i + n]) //行，左下右上对角线，左上右下对角线都没被占 &#123; pos[k] = i; //这行的皇后放在第i列 v[0][i] = v[1][k + i] = v[2][k - i + n] = 1; //三个位置被占 dfs(k + 1); //枚举下一行 v[0][i] = v[1][k + i] = v[2][k - i + n] = 0; //进行回溯，还原现场，不影响下一次放 &#125; &#125; &#125;int main()&#123; cin &gt;&gt; n; dfs(0); cout &lt;&lt; cnt; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列]]></title>
    <url>%2F2019%2F04%2F19%2F11%2F</url>
    <content type="text"><![CDATA[HDU - 1231 (一维)给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …,Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。 Input测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( &lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。 Output对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。 Sample Input123456789101112136-2 11 -4 13 -5 -210-10 1 2 3 4 -5 -23 3 7 -2165 -8 3 2 5 01103-1 -5 -23-1 0 -20 Sample Output12345620 11 1310 1 410 3 510 10 100 -1 -20 0 0 Huge input, scanf is recommended. 思想动态规划，dp[i]表示选i作为序列的结尾 状态转移:1.首先选则i作为结尾则 a[i] 必选2.如果dp[i - 1]的 sum 即(dp[i - 1].dat) &lt; 0, 则不选前一段序列，单独以a[i]作为序列方程 ： dp[i] = max(dp[i - 1] + a[i], a[i])本题新增问题: 求出最优序列的左右区间下标运用结构体数组 (由于题设要求最小的l，r下标，则当dp[i - 1] == 0 true时，要进行l，r的更新)由于必选a[i], 则下标r必定赋值为 dp[i - 1].dat = i;1.如果选择前一个序列，则l由dp[i - 1].l转移过来2.如果不选择前一个序列，则l更新为当前下标 dp[i - 1].l = i 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e4 + 5;struct node&#123; int dat, l, r; // 和值，序列左右区间 &#125;dp[N];int a[N];int main()&#123; int n, l, r; while(cin &gt;&gt; n &amp;&amp; n) &#123; dp[0].dat = 0; // 边界情况处理 dp[0].l = 1; for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i ++) &#123; dp[i].dat = a[i]; //由于必选a[i]，则值刚开始必有a[i]右区间必为 i dp[i].r = i; if(dp[i - 1].dat &gt;= 0) //选前一个序列 &#123; dp[i].dat += dp[i - 1].dat; //值加上前一个 dp[i].l = dp[i - 1].l; //l由前一个序列转移过来 &#125; else dp[i].l = i; //不选以自己下标作为 左区间 &#125; node ans; ans.dat = -0x3f3f3f3f; //遍历所有找出答案 for(int i = 1; i &lt;= n; i ++) if(ans.dat &lt; dp[i].dat) &#123; ans = dp[i]; &#125; if(ans.dat &lt; 0) //答案为负，则说明全序列都为负，按题设要求输出，0 和 第一个 ，最后一个区间 printf("0 %d %d\n", a[1], a[n]); else printf("%d %d %d\n", ans.dat, a[ans.l], a[ans.r]); //输出答案 &#125; return 0;&#125; 最大子矩阵(二维)给定一个边长为n * m的矩阵，求其中的子矩阵 样例 4 40 -2 -7 09 2 -6 2-4 1 -4 1-1 8 0 -2 最大子阵为: 9 2-4 1-1 8 输出115 思路一暴力枚举 + 前缀和处理时间复杂度: $O(n^4)$1.先用二维前缀和处理从(0,0) 到(i, j)所构成的矩阵2.每个子矩阵求法如下图:$$S[(k, l), (i, j)] = S[(0, 0), (i, j)] - S[(0, 0), (k - 1, j)] - S[(0, 0), (i, l - 1)] + S[(0, 0), (k - 1, l - 1)]$$123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;int a[N][N];int b[N][N];int main()&#123; int n, m, ans = -1e8; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) &#123; scanf("%d", &amp;a[i][j]); b[i + 1][j + 1] = a[i][j] + b[i][j + 1] + b[i + 1][j] - b[i][j]; //下标从0开始对应 + 1 &#125; int sum = 0; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) &#123; for(int k = 0; k &lt;= i; k ++ ) for(int l = 0; l &lt;= j; l ++ ) &#123; int sum = b[i + 1][j + 1] - b[k][j + 1] - b[i + 1][l] + b[k][l]; ans = max(ans, sum); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 思路二动态规划 $O(n^3)$把每一列压为一行，然后用二重循环枚举开头结尾(用前缀和快速求得每次压缩后的一维数组)转化为一维数组问题后，d[i] = max(a[i] + d[i - 1], a[i]), 每次算出值后用更新ans12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 55;int a[N][N];int b[N][N];int main()&#123; int n, m, ans = -1e8; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) &#123; scanf("%d", &amp;a[i][j]); b[i + 1][j + 1] = b[i][j + 1] + a[i][j]; //列方向前缀和 &#125; for(int i = 0; i &lt; n; i ++ ) //二重枚举列方向压缩的起点和终点 for(int j = i; j &lt; n; j ++ ) &#123; int sum = 0; for(int k = 0; k &lt; m; k ++ ) //一维问题 &#123; sum += b[j + 1][k + 1] - b[i][k + 1]; ans = max(ans, sum); if(sum &lt; 0) sum = 0; //小于零则前段扔掉 &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F04%2F19%2F10%2F</url>
    <content type="text"><![CDATA[插入排序$O(n^2)$123456789101112void insertion_sort()&#123; int i, j; cout &lt;&lt; "insertion_sort:\n"; for(i = 1; i &lt; N; i ++ ) &#123; int t = a[i]; for(j = i - 1; j &gt;= 0 &amp;&amp; t &lt; a[j]; j -- ) a[j + 1] = a[j]; a[j + 1] = t; &#125; &#125; 归并排序$O(nlogn)$1234567891011121314151617void merge_sort(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid); merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) if(a[i] &lt;= a[j]) w[k ++ ] = a[i ++ ]; else w[k ++ ] = a[j ++ ]; // cnt += mid – i + 1 归并排序求逆序对 while(i &lt;= mid) w[k ++ ] = a[i ++ ]; while(j &lt;= r) w[k ++ ] = a[j ++ ]; for(i = l, j = 0; j &lt; k; i ++, j ++ ) a[i] = w[j];&#125; $O(nlogn)$ 快速排序12345678910111213void quick_sort(int l, int r)&#123; if(l &gt;= r) return ; int i = l - 1, j = r + 1, x = a[i + j &gt;&gt; 1]; while(i &lt; j) //以中间点为基准，小于的放x左边，大于放右边， //遇到不满足情况两指针都停下来，若i &lt; j则交换，否则以i为基点左右递归 &#123; do j --; while(a[j] &gt; x); do i ++; while(a[i] &lt; x); if(i &lt; j) swap(&amp;a[i], &amp;a[j]); else quick_sort(l, j), quick_sort(j + 1, r); &#125;&#125; (shell)希尔排序$O(n^{1.3}) ~ O(n^2)$123456789101112131415161718void shell_sort()&#123; int gap, i, j, t; gap = 1; while(gap &lt; N / 3) gap = gap * 3 + 1; while(gap) &#123; for(int i = gap; i &lt; N; i ++ ) &#123; t = a[i]; for(j = i - gap; j &gt;= 0 &amp;&amp; t &lt; a[j]; j -- ) a[j + gap] = a[j]; a[j + gap] = t; &#125; gap &gt;&gt;= 1; &#125;&#125; 堆排序$O(nlogn)$123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int h[100006], n;void down(int u) //down操作, 往下调整顺序，递归操作实现(循环也可)&#123; int t = u; //找到父亲与儿子节点中最小的节点 int l = u * 2, r = u * 2 + 1; if(l &lt;= n &amp;&amp; h[l] &lt; h[t]) t = l; if(r &lt;= n &amp;&amp; h[r] &lt; h[t]) t = r; if(t != u) //不同则交换 &#123; swap(h[u], h[t]); down(t); //继续down儿子中较大的点 &#125;&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]); for (int i = n / 2; i; i -- ) down(i); //前从下到上前n - 1个建堆方式，接近O(n) while(m -- ) //输出前m个小的 &#123; printf(&quot;%d &quot;, h[1]); swap(h[1], h[n -- ]); down(1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路模板]]></title>
    <url>%2F2019%2F04%2F19%2F9%2F</url>
    <content type="text"><![CDATA[dijkstra算法dijstra邻接矩阵时间复杂度: $O(n^2)$ 与最小生成树prim算法的联系: d[1] = 0最小生成树T、S集合每次从S中取出一个d[x]最小的来更新S中的所有点，由于T中点在加入前与其他所有点已完成更新，所以不用更新T中的点。 dijkstra: 每次取出一个全局最小的d[x] (未访问过的点)，更新其他所有点 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 3010;int a[N][N], d[N], n, m; //邻接矩阵a，距离，n个点，m条边bool v[N]; //标记数组 void dijkstra()&#123; memset(d, 0x3f, sizeof(d)); //dist初始化为 -inf for(int i = 1; i &lt; n; i ++ ) //顺序枚举每个点，最后一个点时d[n]已被其它所有点所更新，由于是无向图相当于这个点也更新了其它所有点，所以不用要n节点 &#123; int x = 0; //找到未标记dist节点中最小的 for(int j = 1; j &lt;= n; j ++ ) if(!v[j] &amp;&amp; (x == 0 || d[j] &lt; d[x])) x = j; v[x] = 1; for(int y = 1; y &lt;= n; y ++ ) //用全局最小值更新其他节点 d[y] = min(d[y], d[x] + a[x][y]); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //n个节点，m条边 memset(a, 0x3f, sizeof(a)); //所有点距初始化为inf,即没有边相连 for(int i = 1; i &lt;= n; i ++ ) a[i][i] = 0; //自己与自己没有边，距离为0; for(int i = 1; i &lt;= m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); //起点 终点 权值 a[x][y] = a[y][x] = min(z, a[x][y]); //由于可能两点之间多边，又是无向图，连两条边，更新两点之间的最短距离 &#125; prim(); for(int i = 1; i &lt;= n; i ++ ) //每个点的最短距离 printf("%d\n", d[i]); return 0; &#125; dijkstra堆优化时间复杂度: $(m + n)logn -&gt; mlogn$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; #include &lt;cstring&gt;using namespace std;const int N = 5e2; //顶点数 const int M = 5e3; //边数 typedef pair&lt;int, int&gt; PII;int n, m, tot;int edge[M], ver[M], Next[M];int d[N], head[N];bool v[N];void add(int x, int y, int z) //见邻接表存图&#123; ver[++ tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;&#125;void dijkstra()&#123; memset(d, 0x3f, sizeof(d)); //初始距离为inf memset(v, 0 , sizeof(v)); //每个点没有被标记 priority_queue&lt;PII&gt; q; //添-号变成小根堆 q.push(&#123;0, 1&#125;); //1 到 1边权值为 0 d[1] = 0; while(!q.empty()) &#123; int x = q.top().second; //终点 q.pop(); if(v[x]) continue; //访问过的点不在加入 v[x] = 1; for(int i = head[x]; i ; i = Next[i]) //通过边的序号进行遍历，y为终点，z为边权值 &#123; int y = ver[i], z = edge[i]; if(d[y] &gt; d[x] + z) //如果不满足三角形定则，则进行更新 &#123; d[y] = d[x] + edge[i]; q.push(&#123;-d[y], y&#125;); //取-变小根堆，边权值，终点 &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); add(x, y, z); //无向图双向加入 add(y, x, z); &#125; dijkstra(); for(int i = 1; i &lt;= n; i ++ ) //输出每个顶点最短距离 cout &lt;&lt; d[i] &lt;&lt; endl; return 0;&#125; floyd12345678910111213141516171819202122232425262728293031323334// Floyd算法，(n^3)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int d[310][310];int n, m;int main() &#123; cin &gt;&gt; n &gt;&gt; m; // 把d数组初始化为邻接矩阵 memset(d, 0x3f, sizeof(d)); for (int i = 1; i &lt;= n; i++) d[i][i] = 0; for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); d[x][y] = min(d[x][y], z); &#125; // floyd求任意两点间最短路径 for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) //三角形定则更新，从1 -&gt; n最近，则推 1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n每一步都最近，最优子结构问题，dp d[i][j] = min(d[i][j], d[i][k] + d[k][j]); // 输出 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) printf("%d ", d[i][j]); puts(""); &#125;&#125; SPFA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//SPFA算法#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 100010, M = 1000010;int head[N], ver[M], edge[M], Next[M], d[N];int n, m, tot;queue&lt;int&gt; q;bool v[N];void add(int x, int y, int z) &#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;&#125;void spfa() &#123; memset(d, 0x3f, sizeof(d)); // dist数组 memset(v, 0, sizeof(v)); // 是否在队列中 d[1] = 0; v[1] = 1; q.push(1); while (q.size()) &#123; // 取出队头 int x = q.front(); q.pop(); v[x] = 0; // 扫描所有出边 for (int i = head[x]; i; i = Next[i]) &#123; int y = ver[i], z = edge[i]; if (d[y] &gt; d[x] + z) &#123; // 更新，把新的二元组插入堆 d[y] = d[x] + z; if (!v[y]) q.push(y), v[y] = 1; &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; // 构建邻接表 for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); add(x, y, z); &#125; // 求单源最短路径 spfa(); for (int i = 1; i &lt;= n; i++) printf("%d\n", d[i]);&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2F2019%2F04%2F18%2F8%2F</url>
    <content type="text"><![CDATA[prim算法优点：对稠密图效率高缺点：复杂度为 $O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 3010;int a[N][N], d[N], n, m, ans; //邻接矩阵a，最小生成树集合(T)里的点到其它(S)集合的点y (y &lt;- S) d[y] = min(d[y], a[x][y]) // v[y] = 1表示点y在集合T中，否则在其它集合(S)中，按顺序每次枚举结点，加入T集合 bool v[N]; //标记数组 void prim()&#123; memset(d, 0x3f, sizeof(d)); //每个点到T集合的距离初始化为无穷大 for(int i = 1; i &lt; n; i ++ ) //顺序枚举每个点，最后一个点时其它所有点已经被访问d[n]会被自身a[n][n]更新为0，所以不用要n节点 &#123; int x = 0; //记录最近节点下标，每次将第一个数纳入 for(int j = 1; j &lt;= n; j ++ ) //记录离T集合最近的点 if(!v[j] &amp;&amp; (x == 0 || d[j] &lt; d[x])) x = j; v[x] = 1; for(int y = 1; y &lt;= n; y ++ ) //新加入的点与S集合里的点进行y (y 属于 S) 与 T集合最近距离的更新，方便下一次选，没有路径和为inf if(!v[y]) d[y] = min(d[y], a[x][y]); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //n个节点，m条边 memset(a, 0x3f, sizeof(a)); //所有点距初始化为inf,即没有边相连 for(int i = 1; i &lt;= n; i ++ ) a[i][i] = 0; //自己与自己没有边，距离为0; for(int i = 1; i &lt;= m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); //起点 终点 权值 a[x][y] = a[y][x] = min(z, a[x][y]); //由于可能两点之间多边，又是无向图，连两条边，更新两点之间的最短距离 &#125; prim(); for(int i = 2; i &lt;= n; i ++ ) //由于d[1]为0， 所以即从d[2] + ···+ d[n]即可 ans += d[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; kruskal算法$(并查集 + 贪心)$ 优点：复杂度较低 $O(mlogn)$，实现简单缺点：边数较多，即稠密图中效率较低思想 : 通过边进行贪心思想，优先选择边权值小的，并且这两个端点不能在同一个集合里(即不连通，否则加上会出现环) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5e5 + 20; //边集 const int M = 1e5 + 20; //顶点集 struct rec&#123; //线段结构体, 起点，终点，权值 int x, y, z; bool operator &lt; (const rec a) const&#123; //按小权值(e[i].z)排序 return z &lt; a.z; &#125;&#125;e[N];int n, m, ans, fa[M]; //顶点(vertex)数, 边(edge)数，答案，父亲节点(并查集中使用) void init() //并查集 (并查集的初始化不能忘) &#123; for(int i = 1; i &lt;= n; i ++ ) fa[i] = i;&#125;int get(int x)&#123; return fa[x] == x ? x : fa[x] = get(fa[x]);&#125;void unite(int x, int y)&#123; fa[get(x)] = get(y); &#125;bool same(int x, int y)&#123; return get(x) == get(y);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i ++ ) scanf("%d %d %d", &amp;e[i].x, &amp;e[i].y, &amp;e[i].z); init(); //每个节点父亲节点初始化为自身(不能忘记初始化) sort(e + 1, e + m + 1); //按小到大排序 for(int i = 1; i &lt;= m; i ++ ) //按边权值从小到大枚举 &#123; if(same(e[i].x, e[i].y)) //两端点是否连通(父节点是否相同) continue; unite(e[i].x, e[i].y); //两端点不连通，合并两点，加上答案 ans += e[i].z; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度计算]]></title>
    <url>%2F2019%2F04%2F18%2F7%2F</url>
    <content type="text"><![CDATA[高精度(高精度 * int)12345678910111213141516171819vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) //高精度乘法&#123;if(b == 0 || (a.size() == 1 &amp;&amp; a[0] == 0)) //乘积为0的两种特殊情况 return vector&lt;int&gt; (1, 0); //返回容器式的 0 vector&lt;int&gt; c; //答案(由于从低位开始算，最终答案会是逆序) int t = 0; //每一位上的乘积结果 for(int i = a.size() - 1; i &gt;= 0; i -- ) &#123; t += a[i] * b; //模拟人工手算，高精度的每一位乘上b c.push_back(t % 10); //将最低位存入答案，下一位进行计算时需要进位 t /= 10; //进位，右移(模拟手算) &#125; while(t) //剩下的位继续存入答案 &#123; c.push_back(t % 10); //取最低位 t /= 10; //进位，左移，方便与高位进行运算 &#125; return vector&lt;int&gt; (c.rbegin(), c.rend()); //由于答案是逆序的，再逆序返回&#125; 高精度 / int1234567891011121314151617181920212223242526vector&lt;int&gt; div(vector&lt;int&gt; a, int b) //高精度除法&#123; vector&lt;int&gt; res; int t = 0; //进行积累的被除数 bool first = true; //判断第一个没有出现的0为止(前缀会有无用0，这样可以丢弃那些 0) for(int i = 0; i &lt; a.size(); i ++ ) //除法，高位往低位移 &#123; t = t * 10 + a[i]; //模拟手工除法，每次向后移一位 int x = t / b; //每步的除数 if(!first || x) //如果能除数大于0(找到第一个不为0的位置) &#123; first = false; //找到第一个不为0的位置，之后的每步计算结果都记录(包括后面的 0) res.push_back(x); //存入答案，这是正序(由于是高位往低位) &#125; t %= b; //取余数继续进行下一次的除 &#125; return res;&#125;vector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b) //高精度比大小&#123; //a, b都是正序 if(a.size() &gt; b.size()) return a; //a的位数更多 if(a.size() &lt; b.size()) return b; //b的位数更多 if(a &gt; b) return a; //相同位数直接比字典序 return b;&#125; 高精度 + 高精度12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef vector&lt;int&gt; vec;vec pluss(vec a, vec b, int len) //都是vec类型相加，答案最大长度为max_len(a, b) + 1&#123; vec ans; int t = 0; for(int i = 0; i &lt; len; i ++ ) //倒序相加，由于处理时是逆序存入的 &#123; t += a[i] + b[i]; //上一位进来的数 + 本身这位的两位数 ans.push_back(t % 10); //取余 t /= 10; //进位 &#125; if(t) ans.push_back(t); //由于答案 &gt;= max_len return vec (ans.rbegin(), ans.rend()); //调整为正序返回&#125;char s1[501], s2[501];int main()&#123; int i, k, len = 0; vec a(500), b(500); scanf("%s", s1); for(i = strlen(s1) - 1, k = 0; i &gt;= 0; i --, k ++ ) //逆序输入处理 a[k] = s1[i] - '0'; len = max(len, k); scanf("%s", s2); for(i = strlen(s2) - 1, k = 0; i &gt;= 0; i --, k ++ ) b[k] = s2[i] - '0'; len = max(len, k); vec res = pluss(a, b, len); for(auto x : res) cout &lt;&lt; x; return 0;&#125; 高精度 - 高精度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;char a[100005], b[100005];int l1, l2;bool cmp()&#123; if(l1 &gt; l2) return true; if(l1 &lt; l2) return false; if(strcmp(a, b) &gt;= 0) return true; return false;&#125;void print(char a[], int l1)&#123; for(int i = 0; i &lt; l1; i ++ ) &#123; if(a[i] &gt; '0') &#123; puts(a + i); return; &#125; &#125; puts("0");&#125;void work(char a[], int l1, char b[], int l2)&#123; for(int i = l1 - 1, j = l2 - 1; ~i; i -- , j -- ) &#123; if(j &gt;= 0) a[i] = a[i] - b[j] + '0'; if(a[i] &lt; '0') a[i - 1] --, a[i] += 10; &#125; print(a, l1);&#125;int main()&#123; scanf("%s %s", a, b); l1 = strlen(a), l2 = strlen(b); if(cmp()) work(a, l1, b, l2); else &#123; printf("-"); work(b, l2, a, l1); &#125; return 0;&#125; 高精度 * 高精度思想：点阵乘法 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef vector&lt;int&gt; vec;vec mul(vec a, vec b, int len)&#123; if(a.size() == 1 &amp;&amp; a[0] == 0 || (b[0] == 0 &amp;&amp; b.size() == 1)) //被乘数含0，直接返回0 return vec (1, 0); vec ans(len); for(int i = 0; i &lt; a.size(); i ++ ) for(int j = 0; j &lt; b.size(); j ++ ) ans[len - 2 - i - j] += a[i] * b[j]; //对应位 for(int i = 0; i &lt; len - 1; i ++ ) &#123; ans[i + 1] += ans[i] / 10; ans[i] %= 10; &#125; if(!ans[len - 1]) ans.pop_back(); //pro最大为a + b, 最小为a + b - 1 return vec (ans.rbegin(), ans.rend()); //还原顺序返回&#125;char s1[501], s2[501];int main()&#123; vec a, b; int len = 0; scanf("%s", s1); //处理输入 for(int i = 0; i &lt; strlen(s1); i ++ ) a.push_back(s1[i] - '0'); len += strlen(s1); scanf("%s", s2); len += strlen(s2); for(int i = 0; i &lt; strlen(s2); i ++ ) b.push_back(s2[i] - '0'); vec res = mul(a, b, len); //最长可能长度 for(auto x : res) cout &lt;&lt; x; return 0;&#125; 高精度 / 高精度思想: 模拟手工计算，对于前l1 ~ l2位每位判断能减几次(高精度减法) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;char str1[105], str2[105];int n1[105], n2[105], ans[105];int check(int a[], int b[], int l1, int l2)&#123; for(int i = l1, j = l2; j &gt;= 1; i --, j -- ) &#123; if(a[i] &gt; b[j]) return 1; if(a[i] &lt; b[j]) return 0; &#125; return 1;&#125; int sub(int a[], int b[], int p, int l2)&#123; for(int i = p - l2 + 1, j = 1; j &lt;= l2; i ++, j ++ ) &#123; a[i] -= b[j]; if(a[i] &lt; 0) a[i] += 10, a[i + 1] --; &#125; &#125;void print(int p)&#123; int f_zero = 0; for(int i = 1; i &lt;= p; i ++ ) &#123; if(f_zero || ans[i]) &#123; f_zero = 1; printf("%d", ans[i]); &#125; &#125; if(!f_zero) printf("0\n");&#125;int main()&#123; scanf("%s %s", str1 + 1, str2 + 1); int l1 = strlen(str1 + 1), l2 = strlen(str2 + 1); for(int i = l1, j = 1; i &gt;= 1; i --, j ++ ) n1[j] = str1[i] - '0'; for(int i = l2, j = 1; i &gt;= 1; i --, j ++ ) n2[j] = str2[i] - '0'; int cnt, k = 0; for(int p = l1; p &gt;= l2; p -- ) &#123; cnt = 0; while(check(n1, n2, p, l2)) &#123; cnt ++; sub(n1, n2, p, l2); &#125; n1[p - 1] += n1[p] * 10; ans[ ++ k] = cnt; &#125; print(k); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化模板]]></title>
    <url>%2F2019%2F04%2F18%2F6%2F</url>
    <content type="text"><![CDATA[离散化123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 4;int a[N]; //原本数组 int ls[N]; //离散化后的数组 int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; a[i]; ls[i] = a[i]; //对原数组进行备份 &#125; sort(ls, ls + n); //对原数组(即备份数组进行排序) int len = unique(ls, ls + n) - ls; //进行去重减少离散长度(避免出现原数组1 1 2 2 离散为1 1 3 3的情况) for(int i = 0; i &lt; n; i ++) a[i] = lower_bound(ls, ls + len, a[i]) - ls + 1; //将原数组进行离散化记录排序下标(即离散化) ，在有效长度len中进行搜索映射 for(int i = 0; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; " "; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集模板]]></title>
    <url>%2F2019%2F04%2F18%2F5%2F</url>
    <content type="text"><![CDATA[标准(自改型和其一样，查询为O(1), 路径压缩 + 按秩合并) 12345678910111213141516171819202122232425262728293031const int MN = 50;int par[MN], heig[MN];void init(int n) //初始化 每个点的根节点先初始化为自己，此时树的高度为0 &#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x) //查找根节点 &#123; if(par[x] == x) return x; //如果找到根节点直接返回（刚开始根节点都初始化为本身） return par[x] = find(par[x]); //递归的进行寻找，从父节点一个一个往上找 &#125;void unite(int x, int y) //合并 &#123; x = find(x); //由于函数里是备份不会改变原有值直接操作 y = find(y); //找到x，y的根节点 if(x == y) return; //如果x，y的根节点相同则不用合并 if(heig[x] &lt; heig[y]) //如果y的深度大于x的深度，x接到y上(出于树防树退化的考虑) par[x] = y; //x的根节点变为y的 else &#123; par[y] = x; //否则y接x上 if(heig[x] == heig[y]) heig[x] ++; //如果出现深度相同的情况，那么x的深度+1(深度相等情况的处理) &#125;&#125;bool same(int x, int y) //查找是否为同一个根节点 &#123; return find(x) == find(y);&#125; 自改型12345678910111213141516171819202122232425262728const int N = par[N], heig[N];void init()&#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x)&#123; if(par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x), y = find(y); if(x == y) return; if(heig[x] &gt; heig[y]) par[y] = x; else if(heig[x] == heig[y]) par[y] = x, heig[x] ++; else par[x] = y;&#125;bool same(int x, int y)&#123; return find(x) == find (y);&#125; 并查集 lyd版(查询logn，只用了路径压缩） 123456789101112131415161718void init()&#123; for(int i = 0; i &lt; n; i ++) a[i] = i;&#125;int get(int x)&#123; return x == f[x] ? x : f[x] = get(f[x]);&#125;void merge(int x, int y)&#123; f[get(x)] = get(y); //直接将x的根节点连在y的根节点上&#125;bool same(int x, int y)&#123; return get(x) == get(y);&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组求逆序对]]></title>
    <url>%2F2019%2F04%2F17%2F3%2F</url>
    <content type="text"><![CDATA[树状数组思想以当前这个数下标i为标准，遍历前面(0 ~ i - 1)的数，如果大于a[i]则逆序对数 + 1，然后运用桶排序的思想，用a[j]的值作为下标，出现则记录为 1，运用树状数组维护前a[i]个数的和然后用 i - sum(a[i]) 即得到前i个数中本应该小于却没有小的数(即逆序对数)bit数组bit[x]代表从a[x - lowbit(x) + 1] ~ a[x]的和 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#define lowbit(x) (x &amp; -x) //lowbit() 运算，取当前第一个 1 出现的位置 using namespace std;const int N = 1e5 + 4;int bit[N]; //bit数组，用二进制思想维护和int n, a[N]; //a数组可有可无，bit的创建通过add(location, value)来确定int sum(int i) //取和操作 &#123; int s = 0; //得到前i个元素的和 //例 : 6 二进制 110, 第一次为自己本身即 s += bit[6] //第二次减去从右往左的第一个1 变为 100 即为4 s += bit[4] //第三次再减去1变为 0 退出 即先使用值再减去第一个 1 for( ; i ; i -= lowbit(i)) s += bit[i]; return s;&#125;void add(int i, int x) //i为位置，x为增量&#123; //与取和操作相反先对 i进行更新，然后加上第一个1之范围会包含原来这个区间，范围更大，都进行更新 //区间最大边界要 &lt;= 最大长度 for( ; i &lt;= n; i += lowbit(i) ) //n为最大限制范围 bit[i] += x; &#125;int main()&#123; cin &gt;&gt; n; int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; //顺序输入 add(a[i], 1); //这个数值进行更新 ans += i - sum(a[i]); //本应小于却没有小于数的个数即为逆序对个数 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树模板]]></title>
    <url>%2F2019%2F04%2F17%2F4%2F</url>
    <content type="text"><![CDATA[lyd 版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1050; //整个大小 int a[N];struct SegmentTree&#123; //线段树结构体，代表每一个节点，左区间，右区间，还有这个区间的特征值(如最大值，最小值) //当 t[ ].l == t[ ].r true时代表一个点 int l, r, dat; &#125;t[N * 4]; //开4倍空间，1. 总数为非2 ^ n 时 logn层即倒数第二层，最后一层还剩了一些节点 // 2. 总数为2 ^ n时为最后一层，还是需要多开一倍(一层),来包涵所有情况void build(int p, int l ,int r) //节点下标，左右区间 &#123; t[p].l = l, t[p].r = r; //建树时记录这个节点代表的区间 if(l == r) &#123; t[p].dat = a[l]; return ; &#125; //如果变成了一个点节点对应原数组值(节点下标类似于堆的储存，为四倍长度) int mid = l + r &gt;&gt; 1; //建树的区间不断分治思想进行划分，左子树 、右子树开始建树 build(p * 2, l, mid); //建立左子树 build(p * 2 + 1, mid + 1, r); //建立右子树 t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //根节点为左右节点的最大值 &#125;//树枝一定有两个叶子节点//证明: 假设树枝只有一个叶子节点，这一个子节点(即叶子)为[x, x]那么往上推，根节点为叶子区间取并，那么根节点也为[x, x]，而根据build函数，l == r true时 //是不会执行子节点的build ，与有子节点矛盾 ，故假设不成立 void change(int p, int x, int v) //节点，修改a[]数组中第几个数，要修改为的值 &#123; if(t[p].l == t[p].r)&#123; t[p].dat = v; return ; &#125; //这个节点区间范围为1(说明找到改的目标值，然后进行 回溯 ，对相关区间的进行更新) (并且这个节点没有子节点) int mid = t[p].l + t[p].r &gt;&gt; 1; //取节点区间的中点值 if(mid &gt;= x) change(p * 2, x, v); //x在这个节点区间的左边，则往下判断左子树 else change(p * 2 + 1, x, v); //x在这个区间的右边，则往下啊判断右子树 t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //通过左右儿子对自己进行更新(前面已经排除没有子节点的情况) &#125; int ask(int p, int l, int r) //节点，待查询的左区间，右区间 &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) return t[p].dat; //如果查询的区间包含节点的区间，直接返回节点的区间 int mid = t[p].l + t[p].r &gt;&gt; 1; //节点区间的中点 int val = -(1 &lt;&lt; 30); //定义负无穷，不会对取最大值造成影响 if(mid &gt;= l) val = max(val, ask(p * 2, l, r)); //如果节点区间中值大于待查询的左边(包含)(空间思考)，搜左子树，进行分治dfs往下搜判断 if(r &gt; mid) val = max(val, ask(p * 2 + 1, l ,r)); // 如果待查询区间在节点区间中点右边(不包含)，搜右子树，进行dfs分治往下搜判断 return val; //返回值， 这个节点对整个区间的贡献 &#125;int main()&#123; build(1, 1, N); //第一个节点，1 —N范围 change(1, 5, 9); //第一个节点，把第五个改为 9 ask(1, 2, 9); //第一个节点，查询2 —9的最值 return 0;&#125; 延迟标记线段树区间查询_spread函数的使用 —add标记支持操作: 区间修改，区间查询和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 1e5 + 10;struct SegmentTree&#123; ll sum, add; //sum为和，add为懒惰标记 // 1.（查询时没有完全覆盖的情况) 即先将值更新左右节点，然后下放用spread()下放add标记，保证递归调用的情况 // 2. 查询时完全覆盖，直接返回当前区间的值（与单点更新版本类似) ,修改时则直接整个区间的sum加上长度 * 修改值d int l, r;&#125;t[N &lt;&lt; 2]; //4倍空间，单点更新中已证明 int a[N], n, m;void build(int p, int l, int r) &#123; t[p].l = l, t[p].r = r; if(l == r) &#123; t[p].sum = a[l]; return ; &#125; //更新到单个点直接对应赋值 int mid = l + r &gt;&gt; 1; build(p &lt;&lt; 1, l , mid); //建左子树区间 build(p &lt;&lt; 1 | 1, mid + 1, r); //建右子树区间 t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; //注意这里是 = 不是 += &#125;void spread(int p) //传递标记的函数 &#123; if(t[p].add) //如果有标记 &#123; //因为最后求得sum是由左右两个区间共同组成，所以先下传add标记(节点所代表的区间完全被覆盖除外, 此时不需要使用左右子树，但是要记录add标记，以后方便使用) t[p &lt;&lt; 1].sum += (ll)t[p].add * (t[p &lt;&lt; 1].r - t[p &lt;&lt; 1].l + 1); //左子树(区间)值更新 t[p &lt;&lt; 1 | 1].sum += (ll)t[p].add * (t[p &lt;&lt; 1 | 1].r - t[p &lt;&lt; 1 | 1].l + 1); //右子树(区间)值更新 t[p &lt;&lt; 1].add += t[p].add; //标记传给左子树 t[p &lt;&lt; 1 | 1].add += t[p].add; //标记传给右子树 t[p].add = 0; //下传标记结束，父亲节点的标记清除 &#125;&#125;void change(int p, int l, int r, int d) //d为待改变的数值 &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) //完全覆盖 &#123; t[p].sum += (ll)d * (t[p].r - t[p].l + 1); //直接整个区间(左端点 - 右端点 + 1)更新 t[p].add += d; //进行标记，便于访问子节点使用 return ; &#125; spread(p); //由于要访问子节点 int mid = t[p].r + t[p].l &gt;&gt; 1; //取节点区间的左右节点 if(mid &gt;= l) change(p &lt;&lt; 1, l, r , d); //子节点中间 &gt;= 查询区间左端点，去左子节点里去访问存在的区间 if(mid &lt; r) change(p &lt;&lt; 1 | 1, l ,r , d); //子节点中间 &lt; 查询区间右端点, 去右子节点里访问存在的区间 t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; //节点和由左右子节点和更新 &#125;ll ask(int p, int l, int r)&#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) return t[p].sum; //如果全部包含，直接返回值(不需要下传标记) spread(p); //没有完全覆盖，需要在左右子节点查询 int mid = t[p].l + t[p].r &gt;&gt; 1; ll val = 0; if(mid &gt;= l) val += ask(p &lt;&lt; 1, l, r); //同上，左右子节点里查询 if(mid &lt; r) val += ask(p &lt;&lt; 1 | 1, l, r); return val;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;a[i]); build(1, 1, n); //建树，下标从1开始，方便对应 p &lt;&lt; 1 和 p &lt;&lt; 1 | 1 的左子节点和右子节点 while(m --) &#123; int l, r, d; char op[2]; //输入格式, 用字符串类型 scanf("%s%d%d", op, &amp;l, &amp;r); if(op[0] == 'C') &#123; scanf("%d", &amp;d); change(1, l, r, d); //区间改值 &#125; else printf("%lld\n", ask(1, l, r)); //询问区间和 &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown示范]]></title>
    <url>%2F2019%2F04%2F16%2F2%2F</url>
    <content type="text"><![CDATA[一级二级三级 列表1 列表2 a 子列表 b 子列表 列表3百度字体是线的哦字体是加粗了的 &lt;html&gt;&lt;/html&gt; 1#include 内容是引用的 $sum$ 12345678910111213141516171819# 一级## 二级### 三级***---***----------- 列表1- 列表2 a 子列表 b 子列表- 列表3 [百度](https://www.baidu.com) ![新客站]() *字体是线的哦* **字体是加粗了的** `&lt;html&gt;&lt;/html&gt;` #include 12&gt; 内容是引用的]]></content>
      <categories>
        <category>语法使用</category>
      </categories>
      <tags>
        <tag>公式语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[耍杂技的牛]]></title>
    <url>%2F2019%2F04%2F16%2F1%2F</url>
    <content type="text"><![CDATA[农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。 奶牛们不是非常有创意，只提出了一个杂技表演： 叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。 奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。 这N头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度Si。 一头牛只撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。 您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。 输入格式第一行输入整数N，表示奶牛数量。 接下来N行，每行输入两个整数，表示牛的重量和强壮程度，第i行表示第i头牛的重量Wi以及它的强壮程度Si。 输出格式输出一个整数，表示最大风险值的最小可能值。 数据范围1≤N≤50000,1≤Wi≤10,000,1≤Si≤1,000,000,000 输入样例：1234310 32 53 3 输出样例：12 题意:给你N头牛，每头牛有两个属性w(重量值)，s(强壮值)，危险值 = 前面所有牛的总重量 - 它身体强壮程度的值, 安排一个顺序使得所有牛中的最大危险值最小 (贪心)思路: 与国王游戏的贪心策略相似， 我们先分析每头牛的危险值 = 他前面牛的w(重量值)和 - 自身的s(强壮值)，要使每头牛的危险值最小，这显然是与w 和 s同时相关，所以先 yy 出一种做法按 每头牛的w + s进行升序排序(题见多了可能就会有这种题感)。接下来进行数学分析证明: 牛 交换前 交换后 $i$ $$\sum_{j=1}^{i-1} w_j - s_i$$ $$\sum_{j=1}^{i-1} w_j + w_{i+1}- s_i$$ $i + 1$ $$\sum_{j=1}^{i} w_j - s_{i+1}$$ $$\sum_{j=1}^{i-1} w_j - s_{i+1}$$ 其他牛的危险值显然不变，所以分析交换前后这两头牛中最大的危险值即可。将上述式子进行化简，每个式子减去 $\sum_{j=1}^{i-1} w_j$得到如下式子 牛 交换前 交换后 $i$ $$-s_i$$ $$w_{i+1}- s_i$$ $i + 1$ $$w_i- s_{i+1}$$ $$- s_{i+1}$$ 由于s, w都是正数，$w_i- s_{i+1} &gt; - s_{i+1}$ , $w_{i+1}- s_i &gt; -s_i$ 比较$ w_i- s_{i+1}$, $w_{i+1}- s_i$即可 当$w_i- s_{i+1} &gt;= w_{i+1}- s_i$，即 $w_i + s_i &gt;= w_{i+1} + s_{i+1}$时, 交换后更优 当$w_i- s_{i+1} &lt; w_{i+1}- s_i$，即 $w_i + s_i &lt; w_{i+1} + s_{i+1}$时, 交换前更优 所以得到做法: 按每头牛的 w + s 进行排序, 当存在逆序时就进行交换(即升序排序)，然后根据题意算出每头牛的危险值记录其中的最大值即可代码:1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;const int N = 5e4 + 5;PII a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); a[i].first = x + y; a[i].second = y; &#125; sort(a, a + n); ll res = -1e18, sum = 0; for(int i = 0; i &lt; n; i ++ ) &#123; sum -= a[i].second; res = max(res, sum); sum += a[i].first; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算竞指南</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
