<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串hash模板]]></title>
    <url>%2F2019%2F04%2F24%2F17%2F</url>
    <content type="text"><![CDATA[思想将每个字母映射成P进制数，一般进制数取131, 13331, 每个字母a - z相应的映射成 1 - 26, 这个数使用unsigned long long进行2^64的自动取模，避免了低效的mod运算。 求一段序列的hash值令$ “axybb” = 1242522 (1, 24, 25, 2, 2)$求xyb的hash值 $ axy = axyb - a * 123^{( 4 - (2 - 1) )} $, 将a左移进行对齐。 tips可以多取几组p(可以取大质数)进行运算，如果都相等则为同一个串。123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 5;typedef unsigned long long ull; //使用unsigned long long 进行自动溢出取模，减少低效的mod运算ull p = 131, h[N], power[N];char str[N];ull get(int l, int r) //计算子串hash值&#123; return h[r] - h[l - 1] * power[r - l + 1]; //类似于前缀和，则输入时下标从1开始，进行左对齐&#125;int main()&#123; scanf("%s", str + 1); //当l == 1时, l - 1 == 0的边界处理。 power[0] = 1; int n = strlen(str + 1); for(int i = 1; i &lt;= n; i ++ ) &#123; h[i] = h[i - 1] * p + str[i] - 'a' + 1; //p进制转换，ull自动取模 power[i] = power[i - 1] * p; //计算p乘方 &#125; int m, l1, l2, r1, r2; cin &gt;&gt; m; while(m -- ) &#123; scanf("%d %d %d %d", &amp;l1, &amp;r1, &amp;l2, &amp;r2); //两个子串 if(get(l1, r1) == get(l2, r2)) //相等判断 cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>字符串hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛法]]></title>
    <url>%2F2019%2F04%2F24%2F18%2F</url>
    <content type="text"><![CDATA[Eratosthenes筛法时间复杂度: $\sum_{质数 p &lt;= N * {\frac Np}} = O(NloglogN) $ 思想:定义一个bool v数组表示是否是合数对于一个从2开始的整数，它的倍数(从2开始)都将是合数，将其全部筛去，剩下的即是素数。 优化对于一个数x，我们可能多次筛它，那么考虑 直接从x x开始筛，因为(x - 1) x在$ x^2 $ 之内的数已经被前面的数筛掉了，所以从 ${x ^ 2} -&gt; {x * k} (k &lt;= n) $123456789101112const int N = 100;int a[N], v[N], m;void primes(int n)&#123; for(int i = 2; i &lt;= n; i ++ ) &#123; if(v[i]) continue; for(int j = i; j &lt;= n / i; j ++ ) v[i * j] = 1; &#125;&#125; 12345678910111213141516const int N = 100;int a[N], v[N], m;int prime[N];void primes(int n)&#123; for(int i = 2; i &lt;= n; i ++ ) &#123; if(!v[i]) v[i] = i, prime[ ++ m] = i; for(int j = 1; j &lt;= m; j ++ ) &#123; if(!(prime[j] &lt;= v[i] &amp;&amp; prime[j] &lt;= n / i)) continue; v[i * prime[j]] = prime[j]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集简单应用]]></title>
    <url>%2F2019%2F04%2F23%2F16%2F</url>
    <content type="text"><![CDATA[食物链动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。 A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。 每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是”1 X Y”，表示X和Y是同类。 第二种说法是”2 X Y”，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。 当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。 你的任务是根据给定的N和K句话，输出假话的总数。 输入格式第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。 输出格式只有一个整数，表示假话的数目。 数据范围1≤N≤50000,0≤K≤100000 输入样例：12345678100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5 输出样例：3 思想:由于有a，b，c三种动物，$a -&gt; b$, $b -&gt; c$, $c -&gt; a$，的这种关系，且题设也没告诉具体是哪种物种，所以三种情况全考虑用0 ~ n - 1表示a，n ~ 2 n - 1表示b, 2 n ~ 3 * n - 1表示c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;algorithm&gt;const int MN = 50005;int par[MN * 3], heig[MN * 3]; //初始化3个 int n, k;void init(int n) //并查集模板 &#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x) &#123; if(par[x] == x) return x; return par[x] = find(par[x]); &#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if(x == y) return; if(heig[x] &lt; heig[y]) par[x] = y; else &#123; par[y] = x; if(heig[x] == heig[y]) heig[x] ++; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;using namespace std;int main()&#123; cin &gt;&gt; n &gt;&gt; k; init(n * 3); int ans = 0; while(k --) &#123; int opt, x, y; scanf("%d %d %d", &amp;opt, &amp;x, &amp;y); if(x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n) //越界错误次数即答案+1 &#123; ans ++; continue; &#125; x -- , y --; //由于下标从0开始，-- 对应 if(opt &amp; 1) //第一种操作 "查询是否为同一物种" &#123; if(same(x, y + n) || same(x, y + 2 * n)) //x，y肯定为同一物种，如果x 和y的其它两种状态任意一种在同一个集合中那么就矛盾，ans ++ ans ++; else &#123; unite(x, y); //每个对应的合并，3种情况全部考虑 unite(x + n, y + n); unite(x + 2 * n, y + 2 * n); &#125; &#125; else &#123; if(same(x, y) || same(x, y + 2 * n)) //如果吃同类或者出现a -&gt; c ,b -&gt; a, c -&gt; b的情况就是错误的，即跨两个吃就是已经逆向循环了 ans++; else &#123; unite(x, y + n); //如果是正确的那么就建立起a -&gt; b, b -&gt; c, c -&gt; a的情形 unite(x + n, y + 2 * n); unite(x + n * 2, y); &#125; &#125; &#125; cout &lt;&lt; ans; return 0;&#125; 网络维修电话线公司（TLC）正在建立一个新的电话电缆网络。它们连接了几个由1到N的整数编号的位置。 没有两个地方有相同的号码。线路是双向的，并且总是将两个地方连接在一起， 并且每个地方线路终止于电话交换机。每个地方都有一个电话交换机。它来自每个地方 可以通过线路到达其他地方，但它不需要是直接连接，它可以通过几次间接连接。 有时电源在某个地方发生故障，因而交换机无法运行。 TLC的官员意识到，在这种情况下， 除了故障的地方无法到达的之外，这也可能导致其他地方无法相互连接。 在这种情况下，我们会说地点（故障的地方）是至关重要的。 现在，官员正试图编写一个程序来查找所有这些关键位置的数量。帮助他们。 输入输入文件由几个行块组成。每个块描述一个网络。在每个块的第一行中，存在N &lt;100的位数。 接下来最多N行中的每一行包含一个地点的编号，后面跟有来自该地方的直线的一些地方的编号。 这些最多N行完全描述了网络，即，网络中两个地方的每个直接连接至少包含在一行中。一行中的所有数字都是分开的 一个。每个块以一条仅包含0的行结束。最后一个块只有一行，N = 0; 输出输出包含除输入文件中的最后一个块之外的每个块，其中一行包含关键位置的数量。 样例输入12345675 1 2 3 4062 1 35 4 6 200 样例输出1212 提示您需要确定一行的结尾。为了使其易于确定，在每行结束之前没有多余的空白。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;struct point&#123; //结构体坐标 (使用pair&lt;&gt;型也可) int x, y;&#125;a[N];int n, d;int par[N], rk[N], vis[N]; //父亲节点，高度，访问标记数组 void init() //初始化每个点一个集合，自己为自己的根节点 &#123; for(int i = 1; i &lt;= n; i ++) par[i] = i;&#125;int find(int x) //寻找根节点 &#123; if(x == par[x]) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y) //根据树的高度进行合并 &#123; x = find(x), y = find(y); if(x == y) return ; if(rk[x] &gt; rk[y]) par[y] = x; else &#123; par[x] = y; if(rk[x] == rk[y]) rk[y] ++; &#125;&#125;bool same(int x, int y) //判断是否为一个集合(即根节点是否相同) &#123; return find(x) == find(y);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; d; init(); for(int i = 1; i &lt;= n ;i ++) cin &gt;&gt; a[i].x &gt;&gt; a[i].y; int t = n + 2; char opt; while(cin &gt;&gt; opt) &#123; int p; cin &gt;&gt; p; if(opt == 'O') &#123; vis[p] = 1; for(int i = 1; i &lt;= n; i ++) if(vis[i]) &#123; int dis = (a[p].x - a[i].x) * (a[p].x - a[i].x) + (a[p].y - a[i].y) *( a[p].y - a[i].y); //哈密顿距离小于给定距离并且次点被 //访问过(即修过)就可以进行合并 if(dis &lt;= d * d) unite(p, i); &#125; &#125; else &#123; int q; cin &gt;&gt; q; if(!vis[q] || !vis[p]) cout &lt;&lt; "FAIL\n"; //如果其中有一个没有被访问过 else if(same(q, p)) cout &lt;&lt; "SUCCESS\n"; //如果都访问过且根节点相同 else cout &lt;&lt; "FAIL\n"; //根基点不同 &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归打印图形]]></title>
    <url>%2F2019%2F04%2F19%2F15%2F</url>
    <content type="text"><![CDATA[分形分形，具有以非整数维形式充填空间的形态特征。 通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。 现在，定义“盒子分形”如下： 一级盒子分形： X二级盒子分形：123X X XX X 如果用B(n - 1)代表第n-1级盒子分形，那么第n级盒子分形即为：12345B(n - 1) B(n - 1) B(n - 1)B(n - 1) B(n - 1) 你的任务是绘制一个n级的盒子分形。 输入格式输入包含几个测试用例。 输入的每一行包含一个不大于7的正整数n，代表要输出的盒子分形的等级。 输入的最后一行为-1，代表输入结束。 输出格式对于每个测试用例，使用“X”符号输出对应等级的盒子分形。 请注意’X’是一个大写字母。 每个测试用例后输出一个独立一行的短划线。 输入样例：123451234-1 输出样例1234567891011121314151617181920212223242526272829303132333435363738394041424344X-X X XX X-X X X X X XX X X X X X X X XX X X X X XX X X X-X X X X X X X X X X X XX X X X X X X X X X X X X X X X X XX X X X X X X X X X X XX X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X XX X X X X X X X X X X XX X X X X X X X X X X X X X X X X XX X X X X X X X X X X XX X X X X X X X- 递归 + 递推优化(减少递归的分支数，减小时间复杂度)对于n级来说，只用画 5 个n - 1级，递归终止条件为 n == 1 true时，然后进行回溯，画剩下的4个(由第n级的 n - 1级复制过来)然后往上继续回溯1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;bool a[N][N]; //由于只有画与不画两种状态(要画的只有一种图形)， int qsm(int a, int b) //快速幂，用来计算len的长度 &#123; int res = 1; while(b) &#123; if(b &amp; 1) res *= a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;void dfs(int n) //n级分形的规划 &#123; if(n == 1) //1级直接画 &#123; a[0][0] = true; //先画左上角 return ; &#125; dfs(n - 1); //进行dfs，靠回溯来完善整个图形 int len = qsm(3, n - 2); //长度为n级的n - 1 级(n级由 5 个 n - 1级组成) ，那么表示就会表示为 3 ^ (n - 2) int px[4] = &#123;0, 1, 2, 2&#125;, py[4] = &#123;2, 1, 0, 2&#125;; //n级里的 其它4个n - 1级的开始坐标(左上角) for(int i = 0; i &lt; 4; i ++ ) //4种情况 for(int j = 0; j &lt; len; j ++ ) //i 表示4个 n - 1级的图形，j, k为横纵坐标(为了进行复制) for(int k = 0; k &lt; len; k ++ ) a[j + px[i] * len][k + py[i] * len] |= a[j][k]; //进行"等位"(加上中心偏移量)复制 &#125;int main()&#123; dfs(7); //预先算出答案，空间换时间 int n; while(cin &gt;&gt; n &amp;&amp; n != -1) &#123; int len = qsm(3, n - 1); //每级的长度为3 ^ n - 1 for(int i = 0; i &lt; len; i ++ ) &#123; for(int j = 0; j &lt; len; j ++ ) if(a[i][j]) cout &lt;&lt; 'X'; //1状态输出'X', 否则为' ' else cout &lt;&lt; ' '; puts(""); //记得换行 &#125; cout &lt;&lt; '-' &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算竞指南</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间贪心问题]]></title>
    <url>%2F2019%2F04%2F19%2F14%2F</url>
    <content type="text"><![CDATA[最小区间覆盖题意: 给定m个区间(左右端点)，求最少用多少个区间能覆盖1 - n思想 : 将所有线段按左端点升序排序 另s = 0，用t进行备份，在左端点不超过的s + 1的前提下找到最远的右端点即while(l &lt;= t + 1) s = max(s, r); 更新完后判断if(s &gt;= r)123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#define l first#define r secondusing namespace std;const int N = 1e5 + 5;typedef pair&lt;int, int&gt; PII;PII a[N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++) scanf("%d %d", &amp;a[i].l, &amp;a[i].r); sort(a, a + m); int s = 0, idx = 0, ans = 0, t; while(s &lt; n &amp;&amp; idx &lt; m) &#123; if(a[idx].l &gt; s + 1) &#123; cout &lt;&lt; "-1"; return 0; &#125; t = s; //开始的位置需要备份， 直到左端点大于 t + 1时退出，这时t再进行更新 while(a[idx].l &lt;= t + 1 &amp;&amp; idx &lt; m) &#123; s = max(s, a[idx].r); //得到可选择中的右边点的最远点 idx ++; &#125; ans ++; t = s; &#125; if(s == n) cout &lt;&lt; ans; //是否达到目标 else cout &lt;&lt; "-1"; return 0;&#125; 畜栏预定有N头牛在畜栏中吃草。 每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。 给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。 当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。 求需要的最小畜栏数目和每头牛对应的畜栏方案。 输入格式第1行：输入一个整数N。 第2..N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。 输出格式第1行：输入一个整数，代表所需最小畜栏数。 第2..N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号从1开始，只要方案合法即可。 数据范围1≤N≤50000,1≤A,B≤1000000 输入样例：12345651 102 43 65 84 7 输出样例：123456412324 方法: 按照起点对所有区间进行排序，然后用小顶堆维护一个最小的右区间，如果右区间 &gt;= 新的左区间，说明只能建立一个新的畜栏 小顶堆更新即可如果右区间 &lt; 左区间，说明可以放在最小右区间那一行中，更新小顶堆即可当前最优解为 k证明: 反证法: 假设存在 m &lt; k 为最优解，另处理第m + 1 牛时为 i，由于是按顺序枚举，则m.l &lt;= i.l，枚举第i头牛时会出现 m.r &gt;= i.l的情况则会出现包含的情况， 需要m + 1个围栏，以此类推到最优解k个12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 50000 + 5;typedef pair&lt;int, int&gt; PII;pair&lt;PII, int&gt; cows[N]; //cows[i].second 记录当前的编号 int id[N]; //默认顺序，之后进行排序会打乱 int main()&#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second; cows[i].second = i; &#125; sort(cows + 1, cows + n + 1); //按区间左端点排序 priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; //小顶堆维护最小右区间 for(int i = 1; i &lt;= n; i ++) &#123; if(q.empty() || q.top().first &gt;= cows[i].first.first) //如果为空或最小右区间大于l，则必须加一个围栏 &#123; PII t = &#123;cows[i].first.second, q.size() + 1&#125;; //牛栏编号为i id[cows[i].second] = t.second; //记录编号 q.push(t); //入堆 &#125; else &#123; PII now = q.top(); //和最小右区间一个栅栏 q.pop(); now.first = cows[i].first.second; //右区间会被更新 id[cows[i].second] = now.second; //这个牛也在这个栅栏 q.push(now); //i继续入堆，让其维护最小的右区间 &#125; &#125; cout &lt;&lt; q.size() &lt;&lt; endl; for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; id[i] &lt;&lt; endl; //按输入顺序，顺序输出每头牛 的栅栏编号 return 0;&#125; 区间选点覆盖雷达设备 假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。 每个小岛都位于海洋一侧的某个点上。 雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。 我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。 现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。 输入格式第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。 接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。 同一行数据之间用空格隔开。 输出格式输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。 数据范围1≤n≤1000 输入样例：12343 21 2-3 12 1 输出样例：12 思想方法，先将题目进行转化，由勾股定理转化为区间问题: 给定n个区间，用最少的点数让每个去区间至少包含一个点做法: 先让区间按照右端点进行排序，然后判断当前左区间是否大于 last(右区间) ，如果大于则 ans ++证明: 假设上述选择出来的区间有 m 个，由于右区间按升序排序，且当前左区间大于上一个的右区间，即每条线段都不相交，那么至少需要m个点来被包含1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef pair&lt;double, double&gt; PDD;const double eps = 1e-6; //浮点数比大小 const int N = 1008;PDD p[N];int main()&#123; int n, x, y, d; double len; cin &gt;&gt; n &gt;&gt; d; for(int i = 0; i &lt; n; i ++) &#123; scanf("%d %d", &amp;x, &amp;y); if(d &lt; y) &#123; cout &lt;&lt; "-1"; return 0; &#125; auto len = sqrt(d * d - y * y); //两次使用，一次定义 p[i] = &#123;x + len, x - len&#125;; //转化为线段(利用勾股定理) &#125; sort(p, p + n); //按右端点升序排列 int ans = 0; double last = -1e10; //上一个的右区间，由于第一个线段必定覆盖则定义为 -inf，让第一个必定满足 for(int i = 0; i &lt; n; i ++) if(p[i].second &gt; last + eps) //小于等于不用更新，相减大于eps则满足条件 &#123; ans ++; last = p[i].first; //更新为当前的右区间 &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倒水问题 + bfs模拟]]></title>
    <url>%2F2019%2F04%2F19%2F13%2F</url>
    <content type="text"><![CDATA[HDU1495 非常可乐大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input1237 4 34 1 30 0 0 Sample Output12NO3 思路，根据题意进行模拟，什么情况下可以倒 (6种情况) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int s, n, m, ans;const int N = 101;bool v[N][N][N]; //判重 struct node&#123; int x, y, z, stp; node(int x, int y, int z, int stp) : x(x), y(y), z(z), stp(stp) &#123; &#125; // 3 + 1个状态 &#125;;bool bfs()&#123; queue&lt;node&gt; q; q.push(&#123;s, 0, 0, 0&#125;); v[s][0][0] = 1; while(!q.empty()) &#123; int sum; node t = q.front(); q.pop(); if((t.x == t.y &amp;&amp; t.x == s &gt;&gt; 1) || (t.x == t.z &amp;&amp; t.x == s &gt;&gt; 1) || (t.y == t.z &amp;&amp; t.y == s &gt;&gt; 1)) //平分总量 &#123; ans = t.stp; //记录答案，返回成功 return true; &#125; for(int i = 0; i &lt; 6; i ++ ) //6种情况 A 3 2 ( 3！) switch(i) &#123; case 0: x -&gt; y if(t.x == 0 || t.y == n) //x瓶没有， y瓶满，不能倒 break; sum = t.x + t.y; //类似于pots问题，先记录总量 if(sum &gt;= n) //倒完还剩一点(可能刚好) ，目标壶会倒满 &#123; if(v[sum - n][n][t.z]) break; v[sum - n][n][t.z] = 1; q.push(&#123;sum - n, n, t.z, t.stp + 1&#125;); &#125; else //起始盆倒空，所有倒入目标盘 &#123; if(v[0][sum][t.z]) break; v[0][sum][t.z] = 1; q.push(&#123;0, sum, t.z, t.stp + 1&#125;); &#125; break; case 1: if(t.x == 0 || t.z == m) break; sum = t.x + t.z; if(sum &gt;= m) &#123; if(v[sum - m][t.y][m]) break; v[sum - m][t.y][m] = 1; q.push(&#123;sum - m, t.y, m, t.stp + 1&#125;); &#125; else &#123; if(v[0][t.y][sum]) break; v[0][t.y][sum] = 1; q.push(&#123;0, t.y, sum, t.stp + 1&#125;); &#125; break; case 2: if(t.y == 0 || t.z == m) break; sum = t.y + t.z; if(sum &gt;= m) &#123; if(v[t.x][sum - m][m]) break; v[t.x][sum - m][m] = 1; q.push(&#123;t.x ,sum - m, m, t.stp + 1&#125;); &#125; else &#123; if(v[t.x][0][sum]) break; v[t.x][0][sum] = 1; q.push(&#123;t.x, 0, sum, t.stp + 1&#125;); &#125; case 3: if(t.y == n || t.z == 0) break; sum = t.y + t.z; if(sum &gt;= n) &#123; if(v[t.x][n][sum - n]) break; v[t.x][n][sum - n] = 1; q.push(&#123;t.x , n, sum - n, t.stp + 1&#125;); &#125; else &#123; if(v[t.x][sum][0]) break; v[t.x][sum][0] = 1; q.push(&#123;t.x, sum, 0, t.stp + 1&#125;); &#125; break; case 4: if(t.y == 0 || t.x == s) //向最大壶倒，不可能溢出和留下水 ，全部倒入，自身变 0 break; sum = t.y + t.x; if(v[sum][0][t.z]) break; v[sum][0][t.z] = 1; q.push(&#123;sum, 0, t.z, t.stp + 1&#125;); case 5: if(t.z == 0 || t.x == s) break; sum = t.z + t.x; if(v[sum][t.y][0]) break; v[sum][t.y][0] = 1; q.push(&#123;sum, t.y, 0, t.stp + 1&#125;); &#125; &#125; return false; &#125;int main()&#123; while(scanf("%d %d %d", &amp;s, &amp;n, &amp;m) == 3 &amp;&amp; s) &#123; memset(v, 0, sizeof(v)); if(s &amp; 1) cout &lt;&lt; "NO\n"; //奇数水量无法平分 else if(bfs()) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; "NO\n"; &#125; return 0;&#125; Pots POJ - 3414模拟bfs（涉及最小步数问题) 你有两个罐子，分别有A和B升的体积。可以执行以下操作： FILL（i）把水壶i倒满(1≤i≤2）;DROP（i）把水壶i倒空;POUR（i，j）从锅i倒入锅j;在此操作之后，罐j已满（并且罐i中可能存在一些水），或罐i是空的（并且其所有水已被移动到罐j）。编写一个程序来找到这些操作的最短可能序列，这些操作将在其中一个罐中产生完全C升的水。 输入一行上是数字A，B和C.这些都是1到100之间的整数，并且C≤max（A，B）。 输出输出的第一行必须包含操作序列K的长度。以下K行必须各自描述一个操作。如果有几个最小长度的序列，则输出其中任何一个。如果无法实现所需的结果，则文件的第一行和唯一行必须包含“impossible”一词。 样本输入13 5 4 样本输出12345676FILL（2）POUR（2,1）DROP（1）POUR（2,1）FILL（2）POUR（2,1） 思路6种情况，进行判重，由于每个节点由一个前驱节点转移过来，所以用node pre[N][N]保存前驱节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int a, b, c;const int N = 115;bool v[N][N];vector&lt;int&gt; path; //倒序输出节点 struct node&#123; int x, y, stp; node() &#123; &#125; node(int x, int y, int stp) : x(x), y(y), stp(stp) &#123; &#125;&#125;;node pre[N][N], ans; //保存前驱点 bool bfs()&#123; int sum; queue&lt;node&gt; q; q.push(&#123;0, 0, 0&#125;); v[a][b] = 1; while(!q.empty()) &#123; node t = q.front(); q.pop(); if(t.x == c || t.y == c) &#123; ans = t; return true; &#125; for(int i = 0; i &lt; 6; i ++ ) &#123; node ne = t; switch(i) &#123; case 0: //把x瓶倒满 ne.x = a; break; case 1: ne.y = b; //把y瓶倒满 break; case 2: ne.x = 0; //把x瓶倒空 break; case 3: ne.y = 0; //把y瓶倒空 break; case 4: sum = ne.x + ne.y; //总水量 if(sum &gt;= b) //倒入y中，多余的部分倒入x中 ne.y = b, ne.x = sum - b; else ne.x = 0, ne.y = sum; break; case 5: sum = ne.x + ne.y; if(sum &gt;= a) //倒入x中，多余的部分导入y中 ne.x = a, ne.y = sum - a; else ne.x = sum, ne.y = 0; break; &#125; if(!v[ne.x][ne.y]) //判重，由于每个点只访问一次 &#123; pre[ne.x][ne.y] = &#123;t.x, t.y, i&#125;; q.push(&#123;ne.x, ne.y, t.stp + 1&#125;); &#125; v[ne.x][ne.y] = 1; &#125; &#125; return false;&#125;void print()&#123; cout &lt;&lt; ans.stp &lt;&lt; endl; while(!(ans.x == 0 &amp;&amp; ans.y == 0)) //从终点开始往前找前驱节点直到起点 &#123; int i = pre[ans.x][ans.y].stp; path.push_back(i); ans = pre[ans.x][ans.y]; &#125; reverse(path.begin(), path.end()); //反向找的，逆序回来 for(vector&lt;int&gt; :: iterator i = path.begin(); i &lt; path.end(); i ++) switch(*i) &#123; case 0: //6种情况对应输出 cout &lt;&lt; "FILL(1)\n"; break; case 1: cout &lt;&lt; "FILL(2)\n"; break; case 2: cout &lt;&lt; "DROP(1)\n"; break; case 3: cout &lt;&lt; "DROP(2)\n"; break; case 4: cout &lt;&lt; "POUR(1,2)\n"; break; case 5: cout &lt;&lt; "POUR(2,1)\n"; break; &#125;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(bfs()) print(); else cout &lt;&lt; "impossible\n" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N 皇后问题 HDU - 2553]]></title>
    <url>%2F2019%2F04%2F19%2F12%2F</url>
    <content type="text"><![CDATA[在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input12341850 Sample Output12319210 思想:按行枚举，每一行只能放一个皇后，三个标记变量，v[0]-列，v[1]-左下对角线，v[2]-右上对角线 ，表示这个地方是否被占 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 15;int a[N][N], pos[N];bool v[3][N * 3]; int n, cnt;void print() //打印结果函数 &#123; for(int i = 0; i &lt; n; i ++ ) &#123; for(int j = 0; j &lt; n; j ++ ) &#123; if(pos[i] == j) //找到每行所放的皇后位置 cout &lt;&lt; 'X'; else cout &lt;&lt; 'O'; &#125; cout &lt;&lt; '\n'; &#125; puts("");&#125;void dfs(int k)&#123; if(k == n) //放到第n行，即皇后全部放完，记录答案，打印 &#123; cnt ++; print(); return ; &#125; for(int i = 0; i &lt; n; i ++ ) &#123; if(!v[0][i] &amp;&amp; !v[1][k + i] &amp;&amp; !v[2][k - i + n]) //行，左下右上对角线，左上右下对角线都没被占 &#123; pos[k] = i; //这行的皇后放在第i列 v[0][i] = v[1][k + i] = v[2][k - i + n] = 1; //三个位置被占 dfs(k + 1); //枚举下一行 v[0][i] = v[1][k + i] = v[2][k - i + n] = 0; //进行回溯，还原现场，不影响下一次放 &#125; &#125; &#125;int main()&#123; cin &gt;&gt; n; dfs(0); cout &lt;&lt; cnt; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列]]></title>
    <url>%2F2019%2F04%2F19%2F11%2F</url>
    <content type="text"><![CDATA[HDU - 1231 (一维)给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …,Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。 Input测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( &lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。 Output对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。 Sample Input123456789101112136-2 11 -4 13 -5 -210-10 1 2 3 4 -5 -23 3 7 -2165 -8 3 2 5 01103-1 -5 -23-1 0 -20 Sample Output12345620 11 1310 1 410 3 510 10 100 -1 -20 0 0 Huge input, scanf is recommended. 思想动态规划，dp[i]表示选i作为序列的结尾 状态转移:1.首先选则i作为结尾则 a[i] 必选2.如果dp[i - 1]的 sum 即(dp[i - 1].dat) &lt; 0, 则不选前一段序列，单独以a[i]作为序列方程 ： dp[i] = max(dp[i - 1] + a[i], a[i])本题新增问题: 求出最优序列的左右区间下标运用结构体数组 (由于题设要求最小的l，r下标，则当dp[i - 1] == 0 true时，要进行l，r的更新)由于必选a[i], 则下标r必定赋值为 dp[i - 1].dat = i;1.如果选择前一个序列，则l由dp[i - 1].l转移过来2.如果不选择前一个序列，则l更新为当前下标 dp[i - 1].l = i 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e4 + 5;struct node&#123; int dat, l, r; // 和值，序列左右区间 &#125;dp[N];int a[N];int main()&#123; int n, l, r; while(cin &gt;&gt; n &amp;&amp; n) &#123; dp[0].dat = 0; // 边界情况处理 dp[0].l = 1; for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i ++) &#123; dp[i].dat = a[i]; //由于必选a[i]，则值刚开始必有a[i]右区间必为 i dp[i].r = i; if(dp[i - 1].dat &gt;= 0) //选前一个序列 &#123; dp[i].dat += dp[i - 1].dat; //值加上前一个 dp[i].l = dp[i - 1].l; //l由前一个序列转移过来 &#125; else dp[i].l = i; //不选以自己下标作为 左区间 &#125; node ans; ans.dat = -0x3f3f3f3f; //遍历所有找出答案 for(int i = 1; i &lt;= n; i ++) if(ans.dat &lt; dp[i].dat) &#123; ans = dp[i]; &#125; if(ans.dat &lt; 0) //答案为负，则说明全序列都为负，按题设要求输出，0 和 第一个 ，最后一个区间 printf("0 %d %d\n", a[1], a[n]); else printf("%d %d %d\n", ans.dat, a[ans.l], a[ans.r]); //输出答案 &#125; return 0;&#125; 最大子矩阵(二维)给定一个边长为n * m的矩阵，求其中的子矩阵 样例 4 40 -2 -7 09 2 -6 2-4 1 -4 1-1 8 0 -2 最大子阵为: 9 2-4 1-1 8 输出115 思路一暴力枚举 + 前缀和处理时间复杂度: $O(n^4)$1.先用二维前缀和处理从(0,0) 到(i, j)所构成的矩阵2.每个子矩阵求法如下图:$$S = S(i,j) - S(k - 1,j) - S(i, l - 1) + S(k - 1, l - 1)$$123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;int a[N][N];int b[N][N];int main()&#123; int n, m, ans = -1e8; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) &#123; scanf("%d", &amp;a[i][j]); b[i + 1][j + 1] = a[i][j] + b[i][j + 1] + b[i + 1][j] - b[i][j]; //下标从0开始对应 + 1 &#125; int sum = 0; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) &#123; for(int k = 0; k &lt;= i; k ++ ) for(int l = 0; l &lt;= j; l ++ ) &#123; int sum = b[i + 1][j + 1] - b[k][j + 1] - b[i + 1][l] + b[k][l]; ans = max(ans, sum); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 思路二动态规划 $O(n^3)$把每一列压为一行，然后用二重循环枚举开头结尾(用前缀和快速求得每次压缩后的一维数组)转化为一维数组问题后，d[i] = max(a[i] + d[i - 1], a[i]), 每次算出值后用更新ans12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 55;int a[N][N];int b[N][N];int main()&#123; int n, m, ans = -1e8; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) &#123; scanf("%d", &amp;a[i][j]); b[i + 1][j + 1] = b[i][j + 1] + a[i][j]; //列方向前缀和 &#125; for(int i = 0; i &lt; n; i ++ ) //二重枚举列方向压缩的起点和终点 for(int j = i; j &lt; n; j ++ ) &#123; int sum = 0; for(int k = 0; k &lt; m; k ++ ) //一维问题 &#123; sum += b[j + 1][k + 1] - b[i][k + 1]; ans = max(ans, sum); if(sum &lt; 0) sum = 0; //小于零则前段扔掉 &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F04%2F19%2F10%2F</url>
    <content type="text"><![CDATA[插入排序$O(n^2)$123456789101112void insertion_sort()&#123; int i, j; cout &lt;&lt; "insertion_sort:\n"; for(i = 0; i &lt; N; i ++ ) &#123; int t = a[i]; for(j = i - 1; j &gt;= 0 &amp;&amp; t &lt; a[j]; j -- ) a[j + 1] = a[j]; a[j + 1] = t; &#125; &#125; 归并排序1234567891011121314151617void merge_sort(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid); merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) if(a[i] &lt;= a[j]) w[k ++ ] = a[i ++ ]; else w[k ++ ] = a[j ++ ]; // cnt += mid – i + 1 归并排序求逆序对 while(i &lt;= mid) w[k ++ ] = a[i ++ ]; while(j &lt;= r) w[k ++ ] = a[j ++ ]; for(i = l, j = 0; j &lt; k; i ++, j ++ ) a[i] = w[j];&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路模板]]></title>
    <url>%2F2019%2F04%2F19%2F9%2F</url>
    <content type="text"><![CDATA[邻接表存图1234567891011int n, m, tot; //n个点，m条边，tot为边的个数int edge[M], ver[M], Next[M]; //边权值，顶点，接着的边（tot序号）int d[N], head[N]; //每个点的最短距离，链表头bool v[N]; //访问标记void add(int x, int y, int z) //起点，终点，边权值&#123; ver[++ tot] = y; //终点 edge[tot] = z; //这个边的边权值 Next[tot] = head[x]; //由于从链表头开始插入，则表头存这个边的序号 head[x] = tot; //这边链接的下一个连接原来的表头，最后传递遍历到0，表示结束&#125; dijkstra算法dijstra邻接矩阵时间复杂度: $O(n^2)$ 与最小生成树prim算法的联系: d[1] = 0最小生成树T、S集合每次从S中取出一个d[x]最小的来更新S中的所有点，由于T中点在加入前与其他所有点已完成更新，所以不用更新T中的点。 dijkstra: 每次取出一个全局最小的d[x] (未访问过的点)，更新其他所有点12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 3010;int a[N][N], d[N], n, m; //邻接矩阵a，距离，n个点，m条边bool v[N]; //标记数组 void dijkstra()&#123; memset(d, 0x3f, sizeof(d)); //dist初始化为 -inf for(int i = 1; i &lt; n; i ++ ) //顺序枚举每个点，最后一个点时d[n]已被其它所有点所更新，由于是无向图相当于这个点也更新了其它所有点，所以不用要n节点 &#123; int x = 0; //找到未标记dist节点中最小的 for(int j = 1; j &lt;= n; j ++ ) if(!v[j] &amp;&amp; (x == 0 || d[j] &lt; d[x])) x = j; v[x] = 1; for(int y = 1; y &lt;= n; y ++ ) //用全局最小值更新其他节点 d[y] = min(d[y], d[x] + a[x][y]); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //n个节点，m条边 memset(a, 0x3f, sizeof(a)); //所有点距初始化为inf,即没有边相连 for(int i = 1; i &lt;= n; i ++ ) a[i][i] = 0; //自己与自己没有边，距离为0; for(int i = 1; i &lt;= m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); //起点 终点 权值 a[x][y] = a[y][x] = min(z, a[x][y]); //由于可能两点之间多边，又是无向图，连两条边，更新两点之间的最短距离 &#125; prim(); for(int i = 1; i &lt;= n; i ++ ) //每个点的最短距离 printf("%d\n", d[i]); return 0; &#125; dijkstra堆优化时间复杂度: $(m + n)logn -&gt; mlogn$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; #include &lt;cstring&gt;using namespace std;const int N = 5e2; //顶点数 const int M = 5e3; //边数 typedef pair&lt;int, int&gt; PII;int n, m, tot;int edge[M], ver[M], Next[M];int d[N], head[N];bool v[N];void add(int x, int y, int z) //见邻接表存图&#123; ver[++ tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;&#125;void dijkstra()&#123; memset(d, 0x3f, sizeof(d)); //初始距离为inf memset(v, 0 , sizeof(v)); //每个点没有被标记 priority_queue&lt;PII&gt; q; //添-号变成小根堆 q.push(&#123;0, 1&#125;); //1 到 1边权值为 0 d[1] = 0; while(!q.empty()) &#123; int x = q.top().second; //终点 q.pop(); if(v[x]) continue; //访问过的点不在加入 v[x] = 1; for(int i = head[x]; i ; i = Next[i]) //通过边的序号进行遍历，y为终点，z为边权值 &#123; int y = ver[i], z = edge[i]; if(d[y] &gt; d[x] + z) //如果不满足三角形定则，则进行更新 &#123; d[y] = d[x] + edge[i]; q.push(&#123;-d[y], y&#125;); //取-变小根堆，边权值，终点 &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); add(x, y, z); //无向图双向加入 add(y, x, z); &#125; dijkstra(); for(int i = 1; i &lt;= n; i ++ ) //输出每个顶点最短距离 cout &lt;&lt; d[i] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2F2019%2F04%2F18%2F8%2F</url>
    <content type="text"><![CDATA[prim算法优点：对稠密图效率高缺点：复杂度为 $O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 3010;int a[N][N], d[N], n, m, ans; //邻接矩阵a，最小生成树集合(T)里的点到其它(S)集合的点y (y &lt;- S) d[y] = min(d[y], a[x][y]) // v[y] = 1表示点y在集合T中，否则在其它集合(S)中，按顺序每次枚举结点，加入T集合 bool v[N]; //标记数组 void prim()&#123; memset(d, 0x3f, sizeof(d)); //每个点到T集合的距离初始化为无穷大 for(int i = 1; i &lt; n; i ++ ) //顺序枚举每个点，最后一个点时其它所有点已经被访问d[n]会被自身a[n][n]更新为0，所以不用要n节点 &#123; int x = 0; //记录最近节点下标，每次将第一个数纳入 for(int j = 1; j &lt;= n; j ++ ) //记录离T集合最近的点 if(!v[j] &amp;&amp; (x == 0 || d[j] &lt; d[x])) x = j; v[x] = 1; for(int y = 1; y &lt;= n; y ++ ) //新加入的点与S集合里的点进行y (y 属于 S) 与 T集合最近距离的更新，方便下一次选，没有路径和为inf if(!v[y]) d[y] = min(d[y], a[x][y]); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //n个节点，m条边 memset(a, 0x3f, sizeof(a)); //所有点距初始化为inf,即没有边相连 for(int i = 1; i &lt;= n; i ++ ) a[i][i] = 0; //自己与自己没有边，距离为0; for(int i = 1; i &lt;= m; i ++ ) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); //起点 终点 权值 a[x][y] = a[y][x] = min(z, a[x][y]); //由于可能两点之间多边，又是无向图，连两条边，更新两点之间的最短距离 &#125; prim(); for(int i = 2; i &lt;= n; i ++ ) //由于d[1]为0， 所以即从d[2] + ···+ d[n]即可 ans += d[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; kruskal算法$(并查集 + 贪心)$ 优点：复杂度较低 $O(nlogn)$，实现简单缺点：边数较多，即稠密图中效率较低思想 : 通过边进行贪心思想，优先选择边权值小的，并且这两个端点不能在同一个集合里(即不连通，否则加上会出现环) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5e5 + 20; //边集 const int M = 1e5 + 20; //顶点集 struct rec&#123; //线段结构体, 起点，终点，权值 int x, y, z; bool operator &lt; (const rec a) const&#123; //按小权值(e[i].z)排序 return z &lt; a.z; &#125;&#125;e[N];int n, m, ans, fa[M]; //顶点(vertex)数, 边(edge)数，答案，父亲节点(并查集中使用) void init() //并查集 (并查集的初始化不能忘) &#123; for(int i = 1; i &lt;= n; i ++ ) fa[i] = i;&#125;int get(int x)&#123; return fa[x] == x ? x : fa[x] = get(fa[x]);&#125;void unite(int x, int y)&#123; fa[get(x)] = get(y); &#125;bool same(int x, int y)&#123; return get(x) == get(y);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i ++ ) scanf("%d %d %d", &amp;e[i].x, &amp;e[i].y, &amp;e[i].z); init(); //每个节点父亲节点初始化为自身(不能忘记初始化) sort(e + 1, e + m + 1); //按小到大排序 for(int i = 1; i &lt;= m; i ++ ) //按边权值从小到大枚举 &#123; if(same(e[i].x, e[i].y)) //两端点是否连通(父节点是否相同) continue; unite(e[i].x, e[i].y); //两端点不连通，合并两点，加上答案 ans += e[i].z; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度计算]]></title>
    <url>%2F2019%2F04%2F18%2F7%2F</url>
    <content type="text"><![CDATA[高精度(高精度 * int)12345678910111213141516171819vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) //高精度乘法&#123;if(b == 0 || (a.size() == 1 &amp;&amp; a[0] == 0)) //乘积为0的两种特殊情况 return vector&lt;int&gt; (1, 0); //返回容器式的 0 vector&lt;int&gt; c; //答案(由于从低位开始算，最终答案会是逆序) int t = 0; //每一位上的乘积结果 for(int i = a.size() - 1; i &gt;= 0; i -- ) &#123; t += a[i] * b; //模拟人工手算，高精度的每一位乘上b c.push_back(t % 10); //将最低位存入答案，下一位进行计算时需要进位 t /= 10; //进位，右移(模拟手算) &#125; while(t) //剩下的位继续存入答案 &#123; c.push_back(t % 10); //取最低位 t /= 10; //进位，左移，方便与高位进行运算 &#125; return vector&lt;int&gt; (c.rbegin(), c.rend()); //由于答案是逆序的，再逆序返回&#125; 高精度 / int1234567891011121314151617181920212223242526vector&lt;int&gt; div(vector&lt;int&gt; a, int b) //高精度除法&#123; vector&lt;int&gt; res; int t = 0; //进行积累的被除数 bool first = true; //判断第一个没有出现的0为止(前缀会有无用0，这样可以丢弃那些 0) for(int i = 0; i &lt; a.size(); i ++ ) //除法，高位往低位移 &#123; t = t * 10 + a[i]; //模拟手工除法，每次向后移一位 int x = t / b; //每步的除数 if(!first || x) //如果能除数大于0(找到第一个不为0的位置) &#123; first = false; //找到第一个不为0的位置，之后的每步计算结果都记录(包括后面的 0) res.push_back(x); //存入答案，这是正序(由于是高位往低位) &#125; t %= b; //取余数继续进行下一次的除 &#125; return res;&#125;vector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b) //高精度比大小&#123; //a, b都是正序 if(a.size() &gt; b.size()) return a; //a的位数更多 if(a.size() &lt; b.size()) return b; //b的位数更多 if(a &gt; b) return a; //相同位数直接比字典序 return b;&#125; 高精度 + 高精度12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef vector&lt;int&gt; vec;vec pluss(vec a, vec b, int len) //都是vec类型相加，答案最大长度为max_len(a, b) + 1&#123; vec ans; int t = 0; for(int i = 0; i &lt; len; i ++ ) //倒序相加，由于处理时是逆序存入的 &#123; t += a[i] + b[i]; //上一位进来的数 + 本身这位的两位数 ans.push_back(t % 10); //取余 t /= 10; //进位 &#125; if(t) ans.push_back(t); //由于答案 &gt;= max_len return vec (ans.rbegin(), ans.rend()); //调整为正序返回&#125;char s1[501], s2[501];int main()&#123; int i, k, len = 0; vec a(500), b(500); scanf("%s", s1); for(i = strlen(s1) - 1, k = 0; i &gt;= 0; i --, k ++ ) //逆序输入处理 a[k] = s1[i] - '0'; len = max(len, k); scanf("%s", s2); for(i = strlen(s2) - 1, k = 0; i &gt;= 0; i --, k ++ ) b[k] = s2[i] - '0'; len = max(len, k); vec res = pluss(a, b, len); for(auto x : res) cout &lt;&lt; x; return 0;&#125; 高精度 * 高精度思想：点阵乘法 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef vector&lt;int&gt; vec;vec mul(vec a, vec b, int len)&#123; if(a.size() == 1 &amp;&amp; a[0] == 0 || (b[0] == 0 &amp;&amp; b.size() == 1)) //被乘数含0，直接返回0 return vec (1, 0); vec ans(len); for(int i = 0; i &lt; a.size(); i ++ ) for(int j = 0; j &lt; b.size(); j ++ ) ans[len - 2 - i - j] += a[i] * b[j]; //对应位 for(int i = 0; i &lt; len - 1; i ++ ) &#123; ans[i + 1] += ans[i] / 10; ans[i] %= 10; &#125; if(!ans[len - 1]) ans.pop_back(); //pro最大为a + b, 最小为a + b - 1 return vec (ans.rbegin(), ans.rend()); //还原顺序返回&#125;char s1[501], s2[501];int main()&#123; vec a, b; int len = 0; scanf("%s", s1); //处理输入 for(int i = 0; i &lt; strlen(s1); i ++ ) a.push_back(s1[i] - '0'); len += strlen(s1); scanf("%s", s2); len += strlen(s2); for(int i = 0; i &lt; strlen(s2); i ++ ) b.push_back(s2[i] - '0'); vec res = mul(a, b, len); //最长可能长度 for(auto x : res) cout &lt;&lt; x; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化模板]]></title>
    <url>%2F2019%2F04%2F18%2F6%2F</url>
    <content type="text"><![CDATA[离散化123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 4;int a[N]; //原本数组 int ls[N]; //离散化后的数组 int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; a[i]; ls[i] = a[i]; //对原数组进行备份 &#125; sort(ls, ls + n); //对原数组(即备份数组进行排序) int len = unique(ls, ls + n) - ls; //进行去重减少离散长度(避免出现原数组1 1 2 2 离散为1 1 3 3的情况) for(int i = 0; i &lt; n; i ++) a[i] = lower_bound(ls, ls + len, a[i]) - ls + 1; //将原数组进行离散化记录排序下标(即离散化) ，在有效长度len中进行搜索映射 for(int i = 0; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; " "; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集模板]]></title>
    <url>%2F2019%2F04%2F18%2F5%2F</url>
    <content type="text"><![CDATA[标准(自改型和其一样，查询为O(1), 路径压缩 + 按秩合并) 12345678910111213141516171819202122232425262728293031const int MN = 50;int par[MN], heig[MN];void init(int n) //初始化 每个点的根节点先初始化为自己，此时树的高度为0 &#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x) //查找根节点 &#123; if(par[x] == x) return x; //如果找到根节点直接返回（刚开始根节点都初始化为本身） return par[x] = find(par[x]); //递归的进行寻找，从父节点一个一个往上找 &#125;void unite(int x, int y) //合并 &#123; x = find(x); //由于函数里是备份不会改变原有值直接操作 y = find(y); //找到x，y的根节点 if(x == y) return; //如果x，y的根节点相同则不用合并 if(heig[x] &lt; heig[y]) //如果y的深度大于x的深度，x接到y上(出于树防树退化的考虑) par[x] = y; //x的根节点变为y的 else &#123; par[y] = x; //否则y接x上 if(heig[x] == heig[y]) heig[x] ++; //如果出现深度相同的情况，那么x的深度+1(深度相等情况的处理) &#125;&#125;bool same(int x, int y) //查找是否为同一个根节点 &#123; return find(x) == find(y);&#125; 自改型12345678910111213141516171819202122232425262728const int N = par[N], heig[N];void init()&#123; for(int i = 0; i &lt; n; i ++) par[i] = i;&#125;int find(int x)&#123; if(par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x), y = find(y); if(x == y) return; if(heig[x] &gt; heig[y]) par[y] = x; else if(heig[x] == heig[y]) par[y] = x, heig[x] ++; else par[x] = y;&#125;bool same(int x, int y)&#123; return find(x) == find (y);&#125; 并查集 lyd版(查询logn，只用了路径压缩） 123456789101112131415161718void init()&#123; for(int i = 0; i &lt; n; i ++) a[i] = i;&#125;int get(int x)&#123; return x == f[x] ? x : f[x] = get(f[x]);&#125;void merge(int x, int y)&#123; f[get(x)] = get(y); //直接将x的根节点连在y的根节点上&#125;bool same(int x, int y)&#123; return get(x) == get(y);&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组求逆序对]]></title>
    <url>%2F2019%2F04%2F17%2F3%2F</url>
    <content type="text"><![CDATA[思想以当前这个数下标i为标准，遍历前面(0 ~ i - 1)的数，如果大于a[i]则逆序对数 + 1，然后运用桶排序的思想，用a[j]的值作为下标，出现则记录为 1，运用树状数组维护前a[i]个数的和然后用 i - sum(a[i]) 即得到前i个数中本应该小于却没有小的数(即逆序对数) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#define lowbit(x) (x &amp; -x) //lowbit() 运算，取当前第一个 1 出现的位置 using namespace std;const int N = 1e5 + 4;int bit[N]; //bit数组，用二进制思想维护和int n, a[N]; //a数组可有可无，bit的创建通过add(location, value)来确定int sum(int i) //取和操作 &#123; int s = 0; //得到前i个元素的和 //例 : 6 二进制 110, 第一次为自己本身即 s += bit[6] //第二次减去从右往左的第一个1 变为 100 即为4 s += bit[4] //第三次再减去1变为 0 退出 即先使用值再减去第一个 1 for( ; i ; i -= lowbit(i)) s += bit[i]; return s;&#125;void add(int i, int x) //i为位置，x为增量&#123; //与取和操作相反先对 i进行更新，然后加上第一个1之范围会包含原来这个区间，范围更大，都进行更新 //区间最大边界要 &lt;= 最大长度 for( ; i &lt;= n; i += lowbit(i) ) //n为最大限制范围 bit[i] += x; &#125;int main()&#123; cin &gt;&gt; n; int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; //顺序输入 add(a[i], 1); //这个数值进行更新 ans += i - sum(a[i]); //本应小于却没有小于数的个数即为逆序对个数 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树模板]]></title>
    <url>%2F2019%2F04%2F17%2F4%2F</url>
    <content type="text"><![CDATA[lyd 版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1050; //整个大小 int a[N];struct SegmentTree&#123; //线段树结构体，代表每一个节点，左区间，右区间，还有这个区间的特征值(如最大值，最小值) //当 t[ ].l == t[ ].r true时代表一个点 int l, r, dat; &#125;t[N * 4]; //开4倍空间，1. 总数为非2 ^ n 时 logn层即倒数第二层，最后一层还剩了一些节点 // 2. 总数为2 ^ n时为最后一层，还是需要多开一倍(一层),来包涵所有情况void build(int p, int l ,int r) //节点下标，左右区间 &#123; t[p].l = l, t[p].r = r; //建树时记录这个节点代表的区间 if(l == r) &#123; t[p].dat = a[l]; return ; &#125; //如果变成了一个点节点对应原数组值(节点下标类似于堆的储存，为四倍长度) int mid = l + r &gt;&gt; 1; //建树的区间不断分治思想进行划分，左子树 、右子树开始建树 build(p * 2, l, mid); //建立左子树 build(p * 2 + 1, mid + 1, r); //建立右子树 t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //根节点为左右节点的最大值 &#125;//树枝一定有两个叶子节点//证明: 假设树枝只有一个叶子节点，这一个子节点(即叶子)为[x, x]那么往上推，根节点为叶子区间取并，那么根节点也为[x, x]，而根据build函数，l == r true时 //是不会执行子节点的build ，与有子节点矛盾 ，故假设不成立 void change(int p, int x, int v) //节点，修改a[]数组中第几个数，要修改为的值 &#123; if(t[p].l == t[p].r)&#123; t[p].dat = v; return ; &#125; //这个节点区间范围为1(说明找到改的目标值，然后进行 回溯 ，对相关区间的进行更新) (并且这个节点没有子节点) int mid = t[p].l + t[p].r &gt;&gt; 1; //取节点区间的中点值 if(mid &gt;= x) change(p * 2, x, v); //x在这个节点区间的左边，则往下判断左子树 else change(p * 2 + 1, x, v); //x在这个区间的右边，则往下啊判断右子树 t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //通过左右儿子对自己进行更新(前面已经排除没有子节点的情况) &#125; int ask(int p, int l, int r) //节点，待查询的左区间，右区间 &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) return t[p].dat; //如果查询的区间包含节点的区间，直接返回节点的区间 int mid = t[p].l + t[p].r &gt;&gt; 1; //节点区间的中点 int val = -(1 &lt;&lt; 30); //定义负无穷，不会对取最大值造成影响 if(mid &gt;= l) val = max(val, ask(p * 2, l, r)); //如果节点区间中值大于待查询的左边(包含)(空间思考)，搜左子树，进行分治dfs往下搜判断 if(r &gt; mid) val = max(val, ask(p * 2 + 1, l ,r)); // 如果待查询区间在节点区间中点右边(不包含)，搜右子树，进行dfs分治往下搜判断 return val; //返回值， 这个节点对整个区间的贡献 &#125;int main()&#123; build(1, 1, N); //第一个节点，1 —N范围 change(1, 5, 9); //第一个节点，把第五个改为 9 ask(1, 2, 9); //第一个节点，查询2 —9的最值 return 0;&#125; 延迟标记线段树区间查询_spread函数的使用 —add标记支持操作: 区间修改，区间查询和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 1e5 + 10;struct SegmentTree&#123; ll sum, add; //sum为和，add为懒惰标记 // 1.（查询时没有完全覆盖的情况) 即先将值更新左右节点，然后下放用spread()下放add标记，保证递归调用的情况 // 2. 查询时完全覆盖，直接返回当前区间的值（与单点更新版本类似) ,修改时则直接整个区间的sum加上长度 * 修改值d int l, r;&#125;t[N &lt;&lt; 2]; //4倍空间，单点更新中已证明 int a[N], n, m;void build(int p, int l, int r) &#123; t[p].l = l, t[p].r = r; if(l == r) &#123; t[p].sum = a[l]; return ; &#125; //更新到单个点直接对应赋值 int mid = l + r &gt;&gt; 1; build(p &lt;&lt; 1, l , mid); //建左子树区间 build(p &lt;&lt; 1 | 1, mid + 1, r); //建右子树区间 t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; //注意这里是 = 不是 += &#125;void spread(int p) //传递标记的函数 &#123; if(t[p].add) //如果有标记 &#123; //因为最后求得sum是由左右两个区间共同组成，所以先下传add标记(节点所代表的区间完全被覆盖除外, 此时不需要使用左右子树，但是要记录add标记，以后方便使用) t[p &lt;&lt; 1].sum += (ll)t[p].add * (t[p &lt;&lt; 1].r - t[p &lt;&lt; 1].l + 1); //左子树(区间)值更新 t[p &lt;&lt; 1 | 1].sum += (ll)t[p].add * (t[p &lt;&lt; 1 | 1].r - t[p &lt;&lt; 1 | 1].l + 1); //右子树(区间)值更新 t[p &lt;&lt; 1].add += t[p].add; //标记传给左子树 t[p &lt;&lt; 1 | 1].add += t[p].add; //标记传给右子树 t[p].add = 0; //下传标记结束，父亲节点的标记清除 &#125;&#125;void change(int p, int l, int r, int d) //d为待改变的数值 &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) //完全覆盖 &#123; t[p].sum += (ll)d * (t[p].r - t[p].l + 1); //直接整个区间(左端点 - 右端点 + 1)更新 t[p].add += d; //进行标记，便于访问子节点使用 return ; &#125; spread(p); //由于要访问子节点 int mid = t[p].r + t[p].l &gt;&gt; 1; //取节点区间的左右节点 if(mid &gt;= l) change(p &lt;&lt; 1, l, r , d); //子节点中间 &gt;= 查询区间左端点，去左子节点里去访问存在的区间 if(mid &lt; r) change(p &lt;&lt; 1 | 1, l ,r , d); //子节点中间 &lt; 查询区间右端点, 去右子节点里访问存在的区间 t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; //节点和由左右子节点和更新 &#125;ll ask(int p, int l, int r)&#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) return t[p].sum; //如果全部包含，直接返回值(不需要下传标记) spread(p); //没有完全覆盖，需要在左右子节点查询 int mid = t[p].l + t[p].r &gt;&gt; 1; ll val = 0; if(mid &gt;= l) val += ask(p &lt;&lt; 1, l, r); //同上，左右子节点里查询 if(mid &lt; r) val += ask(p &lt;&lt; 1 | 1, l, r); return val;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;a[i]); build(1, 1, n); //建树，下标从1开始，方便对应 p &lt;&lt; 1 和 p &lt;&lt; 1 | 1 的左子节点和右子节点 while(m --) &#123; int l, r, d; char op[2]; //输入格式, 用字符串类型 scanf("%s%d%d", op, &amp;l, &amp;r); if(op[0] == 'C') &#123; scanf("%d", &amp;d); change(1, l, r, d); //区间改值 &#125; else printf("%lld\n", ask(1, l, r)); //询问区间和 &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown示范]]></title>
    <url>%2F2019%2F04%2F16%2F2%2F</url>
    <content type="text"><![CDATA[一级二级三级 列表1 列表2 a 子列表 b 子列表 列表3百度字体是线的哦字体是加粗了的 &lt;html&gt;&lt;/html&gt; 1#include 内容是引用的 $sum$ 12345678910111213141516171819# 一级## 二级### 三级***---***----------- 列表1- 列表2 a 子列表 b 子列表- 列表3 [百度](https://www.baidu.com) ![新客站]() *字体是线的哦* **字体是加粗了的** `&lt;html&gt;&lt;/html&gt;` #include 12&gt; 内容是引用的]]></content>
      <categories>
        <category>语法使用</category>
      </categories>
      <tags>
        <tag>公式语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[耍杂技的牛]]></title>
    <url>%2F2019%2F04%2F16%2F1%2F</url>
    <content type="text"><![CDATA[农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。 奶牛们不是非常有创意，只提出了一个杂技表演： 叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。 奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。 这N头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度Si。 一头牛只撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。 您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。 输入格式第一行输入整数N，表示奶牛数量。 接下来N行，每行输入两个整数，表示牛的重量和强壮程度，第i行表示第i头牛的重量Wi以及它的强壮程度Si。 输出格式输出一个整数，表示最大风险值的最小可能值。 数据范围1≤N≤50000,1≤Wi≤10,000,1≤Si≤1,000,000,000 输入样例：1234310 32 53 3 输出样例：12 (贪心)思路: 与国王游戏的贪心策略相似， 我们先分析每头牛的危险值 = 他前面牛的w(重量值)和 - 自身的s(强壮值)，要使每头牛的危险值最小，这显然是与w 和 s同时相关，所以先 yy 出一种做法按 每头牛的w + s进行升序排序(题见多了可能就会有这种题感)。接下来进行数学分析证明: 牛 交换前 交换后 $i$ $$\sum_{j=1}^{i-1} w_j - s_i$$ $$\sum_{j=1}^{i-1} w_j + w_{i+1}- s_i$$ $i + 1$ $$\sum_{j=1}^{i} w_j - s_{i+1}$$ $$\sum_{j=1}^{i-1} w_j - s_{i+1}$$ 其他牛的危险值显然不变，所以分析交换前后这两头牛中最大的危险值即可。将上述式子进行化简，每个式子减去 $\sum_{j=1}^{i-1} w_j$得到如下式子 牛 交换前 交换后 $i$ $$-s_i$$ $$w_{i+1}- s_i$$ $i + 1$ $$w_i- s_{i+1}$$ $$- s_{i+1}$$ 由于s, w都是正数，$w_i- s_{i+1} &gt; - s_{i+1}$ , $w_{i+1}- s_i &gt; -s_i$ 比较$ w_i- s_{i+1}$, $w_{i+1}- s_i$即可 当$w_i- s_{i+1} &gt;= w_{i+1}- s_i$，即 $w_i + s_i &gt;= w_{i+1} + s_{i+1}$时, 交换后更优 当$w_i- s_{i+1} &lt; w_{i+1}- s_i$，即 $w_i + s_i &lt; w_{i+1} + s_{i+1}$时, 交换前更优 所以得到做法: 按每头牛的 w + s 进行排序, 当存在逆序时就进行交换(即升序排序)，然后根据题意算出每头牛的危险值记录其中的最大值即可代码:1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;const int N = 5e4 + 5;PII a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); a[i].first = x + y; a[i].second = y; &#125; sort(a, a + n); ll res = -1e18, sum = 0; for(int i = 0; i &lt; n; i ++ ) &#123; sum -= a[i].second; res = max(res, sum); sum += a[i].first; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算竞指南</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
